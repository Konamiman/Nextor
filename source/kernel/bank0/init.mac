	.z80
	title	INIT - MSXDOS and DISK BASIC initializer

;===== start add DOS2.50 (build type)
;
	INCLUDE	CONDASM.INC
	INCLUDE CONST.INC
;
;===== end add DOS2.50
;
;	Conditional assembly switch
;
NEW	equ	-1
BANKED	equ	-1
;===== start del DOS2.50 (include CONDASM.INC)
;HYBRID	equ	-1		;DOS1/DOS2 hybrid system
;===== end del DOS2.50
;
;	Some yummy ASCII control characters
;
BELL	equ	07h
TAB	equ	09h
LF	equ	0Ah
CLS	equ	0Ch
CR	equ	0Dh
ESC	equ	1Bh
;
;	MSX specific constants
;
RDSLT	equ	000Ch		;inter-slot read
WRSLT	equ	0014h		;inter-slot write
CALSLT	equ	001Ch		;inter-slot call
ENASLT	equ	0024h		;enable slot
OUTDO	equ	0018h		;output a character
DCOMPR	equ	0020h		;compare HL with DE
ID_BYTE	equ	002Bh
VERSION	equ	002Dh
CHAR_16	equ	0034h
INTRPT	equ	0038h		;hardware interrupt entry
CHGET	equ	009Fh		;Get from console
CHPUT	equ	00A2h
SNSMAT	equ	0141h		;sense key matrix
PHYDIO	equ	0144h		;physical disk read/write
KILBUF	equ	0156h		;flush buffer
CALBAS	equ	0159h		;call BASIC interpreter routine
CHGCPU	equ	0180h
GETCPU	equ	0183h
;
READYR	equ	409Bh		;Warm start of BASIC
INILIN	equ	4173h		;used to execute AUTOEXEC.BAS
if HYBRID
FCERR	equ	475Ah		;
endif
CHKBRN	equ	6EF4h
PRTTTL	equ	7D29h
;
RAMLOW	equ	0F380h		;Beginning of fixed work area for MSX
if HYBRID
USRTAB	equ	0F39Ah		;!=FCERR ==> ROM appl. /w MSX-DOS2
endif
CNSDFG	equ	0F3DEh		;Console display flag
CURLIN	equ	0F41Ch		;Current line number
BUF	equ	0F55Eh		;Line input buffer (used as scratch)
STKTOP	equ	0F674h		;Pointer to bottom of stack
TXTTAB	equ	0F676h		;Beginning of BASIC text
VARTAB	equ	0F6C2h
STREND	equ	0F6C6h		;End of variable storage
MAXFIL	equ	0F85Fh		;Maximum file number
;
			;; RS2IQ equ 0FAF5h
HOKVLD	equ	0FB20h		;RS2IQ+43 Flag table for "hook valid"
DRVTBL	equ	0FB21h		;RS2IQ+44 Table of disk driver slots
HOOKSAV	equ	0FB29h		;RS2IQ+52 Table of disk driver interrupt
;
;	Definition of hooks
;
H.TIMI	equ	0FD9Fh		;hook at TIMI
H.RUNC	equ	0FECBh		;hook at RUNC
H.CLEA	equ	0FED0h		;hook at CLEARC
H.LOPD	equ	0FED5h		;hook at LOPDEF
H.STKE	equ	0FEDAh		;hook set by a auto-start cartridge
;
;	Flags for disk system initialization
;
MAXSEC	equ	0F6ABh		;AUTLIN, used to detect the maximum
				; sector size within the disk system.
DISKID	equ	0FD99h		;DEVICE, used to determine who is going
				; to be the master.
PROCNM	equ	0FD89h		;Used to avoid duplicate initialization
;
;	Extended BIOS hooks.
;
	public	DISINT,ENAINT
FCALL	equ	0FFCAh		;function call entry for devices
DISINT	equ	0FFCFh		;Disable device driver interrupts
ENAINT	equ	0FFD4h		;Enable device driver interrupts
;
;	I/O ports.
;
PPI.AR	equ	0A8h		;PPI Port A data read
PPI.AW	equ	0A8h		;PPI Port A data write
;
;	Disk system characteristics
;
MAXCARD	equ	4		;max number of cartridges
MAXDRV	equ	8		;max number of drives supported by disk
				;system
BOOTAD	equ	0C000h		;boot strap loader address
;
;	Field definition of DPB
;
DRVNUM	equ	0		;drive number
SECSIZ	equ	2		;size of sector in bytes
FATSIZ	equ	16		;size of FAT in sectors
FAT	equ	19		;pointer to FAT
DPBSIZE	equ	21		;number of bytes per one DPB

SCANKEYS_RAM_BASE equ 0A100h

;
;	MACROs
;
PRINTL	macro	NAME,VALUE
	if2
	.PRINTX % Size of NAME = VALUE bytes %
	endif
	endm
;
OUTCHR	macro
	rst	OUTDO
	endm
;
COMPAR	macro
	rst	DCOMPR
	endm
;
CALLDOS	macro	FUNC
	ld	c,FUNC
	jp	GO_DOS2
endm
;
ALIGN	macro	ADDR
    if $-START gt ADDR-ORIGIN
	error	<Code overwraps at ADDR>
	PRINTL	<wrap at ADDR>,%($-START)-(ADDR-ORIGIN)
	org	ADDR-ORIGIN
    else
	PRINTL	<hole at ADDR>,%(ADDR-ORIGIN)-($-START)
	defs	(ADDR-ORIGIN)-($-START),0C9h	;;fill with RET
    endif
endm
;
ORIGIN	equ	4100h		; ROM code starts here.
;
START:
;
	subttl	ROM header

if BANKED
	include	BANK.INC
endif
;
;	Version and copyright strings.
;
_$DOSVER::
DOSV0::
	defb	"Nextor kernel version "
	defb	NXTVER##+"0", ".", NXTV_HI##+"0" 
	
	if 1
	defb ".", NXTV_LO##+"0"
	endif

	INCLUDE betainfo.mac
	defb	0
;
_$DSKBASIC::
	defb	 "Nextor "
	defb	NXTVER##+"0", ".", NXTV_HI##+"0" 
	defb    ".", NXTV_LO##+"0"
	defb     " BASIC"
	defb	 0
;
;===== start mod DOS2.50 (change Copyright string)
	defb	"Copyright (C) "
	defb	R_YEAR##/1000 mod 10 + "0"
	defb	R_YEAR##/ 100 mod 10 + "0"
	defb	R_YEAR##/  10 mod 10 + "0"
	defb	R_YEAR##      mod 10 + "0"
	defb	" Konamiman",0
;
	defb	R_DATE##/1000 mod 10 + "0"
	defb	R_DATE##/ 100 mod 10 + "0"
	defb	R_DATE##/  10 mod 10 + "0"
	defb	R_DATE##      mod 10 + "0"
	defb	0
;
if 0
	defb	"Copyright (C) 2001-"
	defb	R_YEAR##/1000 mod 10 + "0"
	defb	R_YEAR##/ 100 mod 10 + "0"
	defb	R_YEAR##/  10 mod 10 + "0"
	defb	R_YEAR##      mod 10 + "0"
	defb	" Keiko Mizuo",0
endif
;===== end mod DOS2.50
;
;
BIOS_STAT::
	ld	hl,KCONST##
	jr	_GO_BIOS
;
BIOS_IN::
	ld	hl,KCONIN##
	jr	_GO_BIOS
;
BIOS_OUT::
	ld	c,a		;$OUT expects character in [A]
	ld	hl,KCONOUT##
;
_GO_BIOS:
	jp	GO_BIOS##	;Call the KBIOS in kernel page-0
;
;
	subttl	MSX-DOS1 compatible ROM entries (part 1)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   These are the MSX-DOS1 compatible BDOS function  entries  scatterred
;   around  41EFh~55FFh  in MSX-DOS version 1 ROM.  They must be kept as
;   defined because MSXDOS.SYS version 1 calls them directly.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;

;This routine will return NZ if the appropriate slot key is pressed.
;The slot keys are:
;UIOP for slots 0-0 to 0-3
;QWER for slots 1-0 to 1-3
;ASDF for slots 2-0 to 2-3
;ZXCV for slots 3-0 to 3-3
;For unexpanded slots, the key for subslot 0 applies (U, Q, A, Z)

DISABLE_KEY:
	ld a,(BOOTKEYS##+2)
	and 80h
	ret nz	;"N" key pressed?

	call	GSLOT1##
	and	00001111b
	add	a,a
	ld	e,a
	ld	d,0
	ld	hl,DISABLE_TBL
	add	hl,de
	ld	c,(hl)  ;Offset of byte in boot keys area
    inc hl
    ld  b,(hl)  ;Mask in the boot keys byte

    ld hl,BOOTKEYS##
    ld e,c
    ld d,0
    add hl,de
    ld a,(hl)
    and b

	ret

; 0: 76543210
; 1: FEDCBA98
; 2: NMLKJIHG
; 3: VUTSRQPO
; 4: ....ZYXW

DISABLE_TBL:
	db	3, 01000000b	;0-0: U
	db	3, 00000100b	;1-0: Q
	db	1, 00000100b	;2-0: A
	db	4, 00001000b	;3-0: Z

	db	2, 00000100b	;0-1: I
    db	4, 00000001b	;1-1: W
	db	3, 00010000b	;2-1: S
	db	4, 00000010b	;3-1: X

	db	3, 00000001b	;0-2: O
	db	1, 01000000b	;1-2: E
	db	1, 00100000b	;2-2: D
	db	1, 00010000b	;3-2: C

	db	3, 00000010b	;0-3: P
	db	3, 00001000b	;1-3: R
	db	1, 10000000b	;2-3: F 
	db	3, 10000000b	;3-3: V

	ALIGN   41E8h
	jp PROMPT

	ALIGN	41EFh-3
    jp SCANKEYS
CPMVER:	CALLDOS	0Ch	;Return CP/M version number

    ALIGN   4200h

    ;--- BOOT KEY INVERTERS ---
    ;
    ; These two bytes have one bit assigned for each key that has meaning at boot time.
    ; If the bit for one key is set, then the meaning of the key is inverted.
    ;
    ; E.g. if the bit for the SHIFT key is set, then all MSX-DOS kernels will be
    ; disabled by default, but will be enabled if the SHIFT key is pressed
    ; during boot (the opposite of the normal behavior).
    ;
    ; This does NOT have effect when setting the boot keys in RAM
    ; (if boot keys are set in RAM, the keyboard is completely ignored).
    ;
    ; These bytes are fixed at offset 200h (starting at 0) in ROM.
    ; They should be changed in the ROM file before flashing in the hardware.
    ;
    ; Bits are assigned to keys as follows:
    ;
    ; 0: ..54321.
    ; 1: ..CS.... (C = CTRL, S = SHIFT)
    ;
    ; "." bits are currently unused and should always be 0 to ensure compatibility
    ; with possible future extensions.

KEYS_INV_0: db 00h
KEYS_INV_1: db 20h  ;Invert CTRL by default (so internal FDDs get only one drive)

;
;=======================================================================
;
; This routine scans all the numeric and alphabetic keys,
; including the numeric keyboard.
;
; Input: A=0 for international keyboard, 1 for Russian keyboard
; Output: Keys in HLDEB (1 bit each, set if pressed):
;
; B: 76543210
; E: FEDCBA98
; D: NMLKJIHG
; L: VUTSRQPO
; H: ....ZYXW
;
; H holds also the status of CAPS, GRAPH, CTRL and SHIFT on bits 7,6,5,4
; respectively.
; 
; (routine placed here to use a big hole in ROM - may need to be moved
;  if the routine grows)

SK_ROW_0 equ 0
SK_ROW_1 equ 1
SK_ROW_2 equ 2
SK_ROW_3 equ 3
SK_ROW_4 equ 4
SK_ROW_5 equ 5
SK_ROW_6 equ 6
SK_ROW_9 equ 7
SK_ROW_10 equ 8
SK_B equ 9
SK_E equ 10
SK_D equ 11
SK_L equ 12
SK_H equ 13

SK_SIZE equ 14

SCANKEYS::
    ld ix,-SK_SIZE
    add ix,sp
    ld sp,ix

    push af
    ld bc,0700h
    push ix
    pop hl
    call SK_GET_ROWS

    ld bc,0209h
    call SK_GET_ROWS

    pop af
    or a
    jr nz,SCANK_RUSSIAN
    call SK_INTERNATIONAL
    jr SCANK_DONE
SCANK_RUSSIAN:
    call SK_RUSSIAN
SCANK_DONE:

    ld b,(ix+SK_B)
    ld e,(ix+SK_E)
    ld d,(ix+SK_D)
    ld l,(ix+SK_L)
    ld h,(ix+SK_H)

    ld ix,SK_SIZE
    add ix,sp
    ld sp,ix
    ret


    ;* International keyboard layout version

;0: 76543210
;1: ......98
;2: BA......
;3: JIHGFEDC
;4: RQPONMLK 
;5: ZYXWVUTS
;6: .... CAPS GRAPH CTRL SHIFT
;Numeric:
;9:  43210...
;10: ...98765

SK_INTERNATIONAL:

    ;* 0-7

    ld a,(ix+SK_ROW_0)    ;76543210
    ld (ix+SK_B),a

    ;* 8-F

    ld a,(ix+SK_ROW_1)
    and 00000011b
    ld b,a              ;......89

    ld a,(ix+SK_ROW_2)  ;BA......
    rrca
    rrca
    rrca
    rrca
    and 00001100b       ;....BA..
    or b
    ld b,a              ;....BA89

    ld a,(ix+SK_ROW_3)
    rlca
    rlca
    rlca
    rlca
    ld c,a              ;FEDCJIHG
    and 11110000b       ;FEDC....
    or b                ;FEDCBA89

    ld (ix+SK_E),a

    ;* G-N

    ld a,c
    and 00001111b       ;....JIHG
    ld b,a

    ld a,(ix+SK_ROW_4)
    rlca
    rlca
    rlca
    rlca
    ld c,a              ;NMLKRQPO
    and 11110000b       ;NMLK....
    or b                ;NMLKJIHG

    ld (ix+SK_D),a

    ;* O-V

    ld a,c
    and 00001111b       ;....RQPO
    ld b,a

    ld a,(ix+SK_ROW_5)
    rlca
    rlca
    rlca
    rlca
    ld c,a              ;VUTSZYXW
    and 11110000b       ;VUTS....
    or b                ;VUTSRQPO

    ld (ix+SK_L),a

    ;* W-Z 

    ld a,c
    and 00001111b       ;....ZYXW
    ld (ix+SK_H),a
    ld h,a

SK_COMMON:
    ;Input: H = (SK_H)

    ;* CAPS-GRAPH-CTRL-SHIFT

    ld a,(ix+SK_ROW_6)
    rlca
    rlca
    rlca
    rlca
    and 11110000b       ;CAPS-GRAPH-CTRL-SHIFT-ZYXW
    or  h

    ld (ix+SK_H),a

    ;* Numeric keyboard

    ld a,(ix+SK_ROW_9)     ;43210... from numeric keyboard
    rrca
    rrca
    rrca
    and 00011111b
    ld b,a                 ;...43210 from numeric keyboard

    ld a,(ix+SK_ROW_10)    ;...98765 from numeric keyboard
    rlca
    rlca
    rlca
    rlca
    rlca
    ld c,a              ;C = 765...98, we'll use it later
    and 11100000b       ;765..... from numeric keyboard
    or b                ;76543210 from numeric keyboard

    or (ix+SK_B)    ;76543210 from either the regular or the numeric keyboard
    ld (ix+SK_B),a

    ld a,c
    and 00000011b       ;......98 from numeric keyboard
    or (ix+SK_E)        
    ld (ix+SK_E),a      ;FEDCBA98, with 98 from either the regular or the numeric keyboard 

    ret


    ;* Russian keyboard layout version

;0: 654321.9
;1: V.H..087
;2: IF...B..
;3: O.RPAUWS
;4: KJZ.TXDL 
;5: QN.CMGEY
;6: .... CAPS GRAPH CTRL SHIFT
;Numeric:
;9:  43210...
;10: ...98765

SK_RUSSIAN:
    ld a,(ix+SK_ROW_0)
    ld c,a
    ld b,(ix+SK_ROW_1)
    ld e,0

    and 11111100b   ;654321..

    srl b   ;Cy = 7
    rra     ;7654321.
    srl a   ;.7654321

    srl c   ;Cy = 9
    rl e    ;E = .......9

    srl b   ;Cy = 8
    rl e    ;E = ......98

    srl b   ;Cy = 0
    rl a    ;76543210

    ld (ix+SK_B),a
    ld (ix+SK_E),e

    ;I'm sorry but that's it, only 9 disk image files supported in Russian keyboards.
    ;Pull request implementing the (hellish) conversion of the rest of the keys will be welcome.

    xor a
    ld (ix+SK_D),a
    ld (ix+SK_L),a
    ld (ix+SK_H),a

    ld h,a
    jp SK_COMMON


    ;Input:  HL = First work area address, B=Rows count, C=First row
    ;Output: HL = Last work area address used + 1
SK_GET_ROWS:
    ld a,c
    call SNSKEY
    cpl
    ld (hl),a
    inc hl
    inc c
    djnz SK_GET_ROWS
    ret

    ;A clone of the SNSMAT routine in main BIOS
SNSKEY:
	push	bc
	ld	c,a
	di
	in	a,(0AAh)
	and 0F0h
	add	a,c
	out	(0AAh),a
	ei
	in	a,(0A9h)
	pop	bc
	ret
SCEND::

NEWKEY	EQU	0FBE5H
CAPST	EQU	0FCABH
KANAST	EQU	0FCACH
CLIKSW	EQU	0F3DBH
KILBUF	EQU	0156H
CHGET	EQU     09FH

    ;Returns A=1 if we have a Russian keyboard, A=0 otherwise
CHECK_IS_RUSSIAN: ; in case of ZF
	DI
	CALL KILBUF
	LD HL,(CAPST)
	LD A,(CLIKSW)
	PUSH AF
	PUSH HL
	XOR A
	LD (KANAST),A   ; KANA OFF
	LD (CLIKSW),A   ; Shut up!
	DEC A
	LD (CAPST),A    ; CAPS ON
	LD (NEWKEY+6),A ; No SHIFT, CTRL etc.
	LD A,64
	LD B,7
	CALL 0D89H
	POP HL
	POP AF
	LD (CLIKSW),A
	LD (CAPST),HL
	CALL CHGET
	CP "J"
    ld a,1
	RET z
    dec a
    ret


    ;Read key status from RAM.
    ;Out: Z if status read ok, NZ if not
    ;     BEDLH = same as SCANKEYS (if Z)

SCANKEYS_RAM:
    ld b,a
    ld hl,SCANKEYS_RAM_BASE
    ld de,RAMKEYSIG
    call STRCOMP
    ld a,b
    ret nz

    push af
    xor a
    ld (SCANKEYS_RAM_BASE),a
    ld a,(SCANKEYS_RAM_BASE+17) ;After signature, which is 17 bytes long including terminator
    ld b,a
    ld de,(SCANKEYS_RAM_BASE+18)
    ld hl,(SCANKEYS_RAM_BASE+20)
    pop af
    ret

RAMKEYSIG: db "NEXTOR_BOOT_KEYS",0

	ALIGN	436Ch
FDEL:	CALLDOS	13h	;;Delete file (FCB)
;

INITVARS:
	ld	hl,0
	ld	(KER250##),hl
	ld	(KER250##+2),hl

	ld	hl,HOKVLD	;Initialize the extended BIOS entry
	bit	0,(hl)		; if none had already done it.
	jr	nz,FCALLSET
	set	0,(hl)
	ld	hl,FCALL
	ld	b,3*5
SETFCALL:
	ld	(hl),0C9h
	inc	hl
	djnz	SETFCALL
FCALLSET:
	ret

	ALIGN	4392h
FREN:	CALLDOS	17h	;;Rename file (FCB)
;
	ALIGN	4462h
FOPEN:	CALLDOS	0Fh	;;Open file (FCB)
;
	ALIGN	456Fh
FCLOSE:	CALLDOS	10h	;;Close file (FCB)
;
	ALIGN	461Dh
FMAKE:	CALLDOS	16h	;;Create file (FCB)
;
	ALIGN	46BAh
RDABS:	CALLDOS	2Fh	;Absolute sector read
;
	ALIGN	4720h
WRABS:	CALLDOS	30h	;Absolute sector write
;


;--- Check if this slot's INIT has been executed already.
;    This can happen when using a cartridge with a mapper that mirrors
;    information on other pages.
;    Returns normally if code not executed already for this slot,
;    otherwise POPs and RETs.
;
;    (This code placed here to recycle the empty space between BDOS entries)

CHK_DUP::
	call	GSLT1
	pop	hl
	ld	ix,PROCNM-1
	cp	(ix+1)
	ret	z
	cp	(ix+2)
	ret	z
	cp	(ix+3)
	ret	z
	cp	(ix+4)
	ret	z
	push	hl

	ld	b,a
	xor	a
chkslots:
	inc	ix
	cp	(ix)
	jr	nz,chkslots
	ld	(ix),b
	ret

PRT_CRLF:
	push	af
	ld	a,CR
	call	$OUT
	ld	a,LF
	call	$OUT
	pop	af
	ret

	ALIGN	4775h
RDSEQ:	CALLDOS	14h	;;Read sequential (FCB)
;
	ALIGN	477Dh
WRSEQ:	CALLDOS	15h	;;Write sequential (FCB)
;
	ALIGN	4788h
RDRND:	CALLDOS	21h	;;Read random (FCB)
;
	ALIGN	4793h
WRRND:	CALLDOS	22h	;;Write random (FCB)
;
SETF7:
	ld	hl,NEWF7
	ld	de,0F8DFh
	ld	bc,6
	ldir
	jp	MEM_CHK
NEWF7:	db	"load",34,0

	ALIGN	47B2h
RDBLK:	CALLDOS	27h	;;Read random block (FCB)
;
	ALIGN	47BEh
WRBLK:	CALLDOS	26h	;;Write random block (FCB)
;
;
;	Get base address of work area for this cartridge to [IX] and
;	[HL].  preserves [DE].
;
	public	GETWRK
GETWRK:
	call	GET_SLTWRK_ENTRY
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	push	hl
	pop	ix
	ret

	ALIGN	47D1h
WRZER:	CALLDOS	28h	;;Write random with zero fill (FCB)
;

	subttl	Initialize procedures
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	There are about 2K bytes hole from here.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
$$INIT::
	public	INIT
INIT:
	di

	ld	hl,INIT2
	push	hl
	xor	a
	
	;Bank switching code must go here

BSC::
	ld	(6000h),a
	ret
	ds	48-4
INIT2:

	call	CHK_DUP	;Will just POP and RET if slot already processed

    call DO_KEYS_INIT

	call	DISABLE_KEY
	ret	nz
;
if 0 ;; If 0, will boot on MSX1 machine (with calendar clock problem).
	ld	a,(VERSION)
	or	a		;MSX1?
	ret	z		;yes
;
endif
	call	CHK_DRIVER	;Does not return if driver not present

	call	GET_DISKID_HL	;(This part removed to allow SHIFT+4)
	ld	a,(hl)	; (DISKID)	;Am I supposed to be the master?
	or	a
;===== start mod DOS2.50 (build type)
if STURBO
;;if HYBRID
;===== end mod DOS2.50
	jp	m,KILL_DISK
else
	ret	m		;Disk system had been disabled
endif
;
;===== start mod DOS2.50 (build type)
if STURBO
;;if HYBRID
;===== end mod DOS2.50
	jp	nz,VER_CHK	;Skip if I am not the first cartridge
else
	jr	nz,VER_CHK	;Skip if I am not the first cartridge
endif
;
;	I am the first disk cartridge.
;
	call	INITVARS

    ld a,CLS
    call CHPUT
;
;	I can be the master.  Check if disk system can start up.
;

	ld	hl,(BOTTOM##)	;If somebody else has already allocated
	ld	de,0C000h+1	; memory above BOTTOM (or the memory was
	COMPAR			; less than 16K --- can't be for MSX2),
	jr	nc,KILL_DISK	; kill the disk system.
;
	ld	hl,(HIMEM##)	;If somebody else has already allocated
	ld	de,RAMLOW	; memory below RAMLOW (F380h),
	COMPAR			; kill the disk system.
	jr	nz,KILL_DISK	;
;
    ld a,(BOOTKEYS##+4)
    and 00010000b
	di
	rrca
	jr	z,NOTKILL	;If SHIFT key is pressed, kill the disk system
;
KILL_DISK:
	ld	a,(DISKID)
	cp	0FFh
	jr	nz,NOFFKILL	;Needed if the first kernel was MSX-DOS
	xor	a
NOFFKILL:
	ld	(PROCNM+8),a
	ld	b,a
	ld	a,-1		;Kill the entire disk system.
	ld	(DISKID),a
	ld	a,b
	inc	a
	jr	nz,NOTKILL
;===== start mod DOS2.50 (build type)
if STURBO
	ld	a,(VERSION)
	cp	3		;MSXturboR?
	ret	c		;no

    ld a,(BOOTKEYS##)
    and 00000010b ;Scan "1" key
	ld	a,82h		;If "1" key is NOT being pressed
	call z,CHGCPU	; switch to Super-Turbo mode.
endif
;;if HYBRID
;;	xor	a
;;	call	SNSMAT
;;	bit	1,a
;;	ld	a,82h
;;	call	nz,CHGCPU
;;endif
;===== end mod DOS2.50
	ret
;
NOTKILL:
	call	SETF7	;MEM_CHK		;If enough memory was not available
	jr	nc,MEM_CHK_OK1
	;ret	c		; give DOS1 a chance to be the master.
	ld	a,1
	ld	(PROCNM+7),a
MEM_CHK_OK1:
;
	ld	hl,DATASIZE##	;Try to allocate fixed system work area
	call	ALLOC##		; just below RAMLOW.
	ret	c		;Be paranoid, this can't fail.
;
;	I am the master.
;
	ld	bc,DATASIZE##	;clear disk system work area
INIWRK:
	xor	a
	ld	(hl),a
	inc	hl
	dec	bc
	ld	a,c
	or	b
	jr	nz,INIWRK
;
	ld	(MAXSEC),bc	;initialize maximum sector size
;
	ld	b,4*2+4*3	;clear DRVTBL and HOOKSAV
	ld	hl,DRVTBL
CLEAR_HOOKSAV:
	ld	(hl),a
	inc	hl
	djnz	CLEAR_HOOKSAV
;
	ld	hl,HOOKBEG##	;initialize hook area for DOS
	ld	b,HOOKLEN##
INIHOOK:
	ld	(hl),0C9h
	inc	hl
	djnz	INIHOOK
;
	ld	hl,RSLREG##	;set RSLREG routine
	ld	(hl),0DBh	;instruction code for "IN A,(PPI.AR)"
	inc	hl
	ld	(hl),PPI.AR
	inc	hl
	ld	(hl),0C9h	;instruction code for "RET"
;
    ld a,(BOOTKEYS##+4) ;Check CTRL key
    and 00100000b
    rrca
    rrca
    rrca
    rrca
    xor 2
	ld	(TARGET##),a
;
	ld	a,BELL		;tell user scanning is over
	OUTCHR
	jr	OVERRIDE
;
VER_CHK:
;
;	I am not the first.  check to see if I can be the new master.
;
	ld	a,(IN_EMU##)	;If in disk emulation mode, disable myself
	or	a
	ret	nz

	ld	a,(NXT_VER##)	;If previous master is MSX-DOS (not Nextor) then I become master.
	or	a
	jr	z,MAST_OK
	cp	16*NXTVER##+NXTV_HI##	;If old master is same or newer than I
	jr	nc,SLAVE	; become its slave.
;
MAST_OK:
	call	MEM_CHK		;Give up If there is not enough memory
	;jp	c,OLDDOS	;ret	c
				;I can't be new master, but can be the
				; slave of current master when it is
				; DOS2 or newer.  Should do?  [HF]
	jr	nc,MEM_CHK_OK2
	ld	a,1
	ld	(PROCNM+7),a
MEM_CHK_OK2:

;
OVERRIDE:
;
;	I am the real master or am overriding the old one.
;
	ld	a,99h		;16*DOSVER##+DOSV_HI##
	ld	(DOS_VER##),a	;set new DOS version
	ld	a,16*NXTVER##+NXTV_HI##
	ld	(NXT_VER##),a
;
;	Set up hook for clean up procedure
;
	call	GSLOT1##	;get slot address
	ld	hl,H.RUNC	;set up hook for clean up procedure
	ld	(hl),0F7h	;instruction code for "RST 30h"
	inc	hl
	ld	(hl),a
	inc	hl
;===== start mod DOS2.50 (avoid assembler bug)
	ld	de,CLEAN
	ld	(hl),e
	inc	hl
	ld	(hl),d
;;	ld	(hl),low(CLEAN)
;;	inc	hl
;;	ld	(hl),high(CLEAN)
;===== end mod DOS2.50
	inc	hl
	ld	(hl),0C9h	;instruction code for "RET"
	;	;
	;	;
	;	;
;
; Fall into the driver initialization of this cartridge.
;

	subttl	Initialize as slave
;
;	I am the slave.
;
SLAVE:
	ld	a,(KER250##+3)
	or	a
	ret	nz	;Return if four 2.50 kernels initialized already

	call	VALTBL		;get number of drives declared so far
	ret	z		;no room is left
	ld	b,a
	ld	a,MAXDRV
	sub	b
	ld	b,a
;
;	There's enough room for additional cartridges and drives
;
	;Temporary work area used:
	;PROCNM+4: Interrupt flag returned by DV_INIT in bit 0
	;          bit 1 is set temporarily if DRV_INIT returns B=255
	;PROCNM+5: Number of required drives, returned by DV_INIT
	;PROCNM+6: Number of drives actually assigned
	;PROCNM+7: 1 to boot in DOS 1 mode
	;PROCNM+8: 1 if device-based driver
	;IN_EMU: 1 if in disk emulation mode (set by AUTODRV in partit.mac)
    ;PROCNM+10: <>0 if the driver provides configuration

	;Calculate how many work area space can be allocated, it will be:
	;(SP) - MAX(C200h, BOTTOM+512)

	ld	de,(BOTTOM)
	inc	d
	inc	d
	ld	a,d
	cp	0C2h
	jr	nc,BOTTOM_OK
	ld	de,0C200h
BOTTOM_OK:
	ld	hl,0
	or	a
	sbc	hl,de	;HL = -DE
	add	hl,sp

    xor a
	call	CALL_DV_INIT
    push af
    pop bc
	ld	e,c
	res	1,e

	push	hl
	ld	hl,RDBANK##
	ld	(BK4_ADD##),hl
	ld	hl,DV_TYPE##
	call	CALDRV##

    ld h,a
	and	1	;Device-based driver?
	ld	(PROCNM+8),a
    ld a,h
	push af
	and 100b
	ld	(PROCNM+10),a
    ld b,a
	pop af
	pop	hl
	jr	z,NO_DEVBASED
	
	ld	b,255

OKDEVBASED:

NO_DEVBASED:
	ld	c,e
	ld	(PROCNM+4),bc
	call	ALLOC##		;Try to allocate work area for my driver
	jp	c,NO_DRIVE	;failed, I cannot be the slave
;
	ex	de,hl		;move base of work area to [DE]
	call	GET_SLTWRK_ENTRY
	ld	(hl),e		;set base of work area in SLTWRK
	inc	hl
	ld	(hl),d
	ld	hl,(MAXSEC)	;get maximum sector size declared so far
	ld	de,512		;get maximum sector size supported by
				; this cartridge
	COMPAR
	jr	nc,BIGENOUGH	;big enough to hold my sector
	ld	(MAXSEC),de	;mine is bigger, overwrite it
BIGENOUGH:

	;If 255 drives requested, call DRV_INIT with A=1 and then COUNTDRV
	;to actually get the number of drives to allocate.
	;(We can't call COUNTDRV before finishing the initialization of the driver)

	ld	a,(PROCNM+5)
	inc	a
	jr	nz,NO255DRIVES
	ld	hl,PROCNM+4
	ld	b,255
	set	1,(hl)
    ld a,1
    call CALL_DV_INIT   ;Initialize environment and hardware
	call COUNTDRV
	ld	(PROCNM+5),a

NO255DRIVES:
	call	VALTBL		;get empty entry again
	ld	hl,DRVTBL
	ld	d,0		;[DE] = offset into DRVTBL
	add	hl,de
	add	hl,de
	ex	de,hl		;get it into DE
;
	ld	a,(PROCNM+5)	;Restore number of required drives
	or	a
	jr	z,DO_INIT_ENV
	ld	h,a

	;ld	a,(TARGET##)
	;or	a
	ld	a,c		;total drives declared so far
	;call	DRIVES##	;get my own drives in [L]
	add	a,h		;add my own
	cp	MAXDRV+1	;enough room for additional drives?
	jr	c,EMPDR1	;yes
	ld	a,MAXDRV	;make total within limit
EMPDR1:
	sub	c
	jr	z,DO_INIT_ENV	;we have no drives (for fail safe)
;
	call	SET_DPBS

DO_INIT_ENV:
	ld	a,(PROCNM+4)
	and	2
	jr	nz,INITENV_DONE
    ld	a,(PROCNM+6)	;only if we haven't done that yet
	ld	b,a
    ld a,1
    call CALL_DV_INIT   ;Initialize environment and hardware
INITENV_DONE:

	;Set entry in KER250 table

	call	GSLT1
	ld	b,a

	ld	hl,KER250-1
FINDKER250:
	inc	hl
	ld	a,(hl)
	or	a
	jr	nz,FINDKER250

	ld	a,(PROCNM+4)
	and	1
	jr	z,NOSETINT
	set	6,b
NOSETINT:
    ld a,(PROCNM+10)
	or a
	jr	z,NOSETCONF
	set 5,b
NOSETCONF:
	ld	(hl),b

	ld	a,(PROCNM+6)
	or	a
	jr	z,NO_DRIVE

	call	GET_DISKID_HL	;ld	hl,DISKID
	inc	(hl)
	ret
;
NO_DRIVE:
NO_DRV2:
	call	GET_DISKID_HL	;ld	hl,DISKID	;Am I the first cartridge?
	inc	(hl)
	dec	(hl)
	ret	nz		;No, nothing to do.
;
	inc	(hl)		;Otherwise, tell others that there
	ret			; is a master.



;
; Now that page-2 and page-3 slot might  have  been  changed  by  mapper
; setup  routine,  dig  into  the dungeon of the stack to patch out "old
; slot" values to the new ones so that they are "restored".
;
;   CAUTION!!	This routine relies heavily on the stack structure of
;		ROM-BIOS's CALSLT routine.  Stack depth since INIT was
;		inter-slot called is VERY significant.  [HF]
;
SPDEPTH	equ	2		;Stack depth in bytes.
;
MEM_CHK:
	call	GSLOT2		;Get current page-2 slot for MAP_SCAN.
	call	MAP_SCAN##
	ret	c
;
	ld	hl,SPDEPTH+3
	add	hl,sp		;Get where old primary slot is saved
	in	a,(PPI.AR)	;Get current primary slot.
	rrd			;Replace the page-2 and page-3 slot
	ld	(hl),a		; with the new one.
;
	call	GSLT1		;Get my slot address
	bit	7,a		;Done if I am not expanded
	ret	z
;
	ld	hl,SPDEPTH+10	;Get where old secondary slot is saved.
	add	hl,sp		;
	ld	c,a
	call	GSLOT3		;Get new RAM primary slot.
	xor	c		;If we are expanded and new mapper RAM
	and	00000011b	; is in the same primary, force SLTTBL
	jr	nz,not_my_slot	; to be "restored" to the new value.
	ld	a,(0FFFFh)	;Get current secondary slot.
	cpl			;
	rrd			;Replace the page-2 and page-3 slot
	ld	(hl),a		; with the new one.
not_my_slot:
	dec	hl		;Where old primary slot is saved.
	in	a,(PPI.AR)	;Get current primary slot.
	rrd			;Replace the page-2 and page-3 slot
	ld	(hl),a		; with the new one.
	ret

	subttl	Clean up procedure
;
CLEAN::
	call	CLEAR_STAT_P2	;ld	hl,H.RUNC	;restore hook to initial value
	ld	b,5
CLEAN1:
	ld	(hl),0C9h
	inc	hl
	djnz	CLEAN1
	call	GET_DISKID_HL	;ld	hl,DISKID
	ld	a,(hl)
	ld	(hl),b		;clear DEVICE
	or	a		;disk system still alive?
	ret	m		;no
;
	ld	d,a		;save number of cartridges
;
	call	VALTBL		;validate the DRVTBL
	ld	($NUMDRV##),a	;set number of drives
;
	ld	a,d		;If DISKID and number of DRVTBL entries
	sub	e		; differ by one, first cartridge has
	jr	z,NO_DUMMY	; a dummy driver,
	dec	a		;Otherwise, both must exactly match.
	jp	nz,PANIC_BADDI	;
DUMMY_DRIVE:
	ld	de,HOOKSAV	;remove the dummy entry
	ld	hl,HOOKSAV+3
	ld	bc,3*4
	ldir
NO_DUMMY:
;
;	Set default variables for disk system
;
	call	GSLOT1##	;Set slot address of the master
	ld	(MASTER_SLOT##),a
	ld	hl,CHAR_16	;Get KANJI range
	ld	de,KANJTABLE##
	ld	bc,4
	ldir

	ld	a,(ID_BYTE)	;Get country code from ROM
	rrca
	rrca
	rrca
	rrca
	and	111b		;Extract date format
	ld	(COUNTRY##),a	;copy it in RAM

;**DOS2 	ld	a,-1
;**DOS2 	ld	(BUFDRNO),a	;invalidate $BUFFER
;**DOS2 	ld	(DIRBFDRV),a	;invalidate $DIRBUF
;**DOS2 	ld	(DAYCNT+1),a	;cancel current date
;**DOS2 	ld	hl,365*4+1	;set default date to 1984-1-1
;**DOS2 	ld	(CURDATE),hl
;**DOS2 	ld	a,CR		;set CONBUF terminator
;**DOS2 	ld	(CONBUF+130),a
;**DOS2 ;
;**DOS2 ;	Set jump instructions
;**DOS2 ;
;**DOS2 	ld	hl,JUMP_VECTORS
;**DOS2 	ld	b,VECTORS
;**DOS2 SET0C3H:
;**DOS2 	ld	(hl),0C3h
;**DOS2 	inc	hl
;**DOS2 	inc	hl
;**DOS2 	inc	hl
;**DOS2 	djnz	SET0C3H
;
;	Set up $AUXIN, $AUXOUT and BDOS entry
;
	ld	hl,AUXBODY##	;Build $AUXIN that always return EOF.
	ld	(hl),3Eh	;"LD A,1Ah"
	inc	hl
	ld	(hl),1Ah
	inc	hl
	ld	b,3+5		;fill rest and $AUXOUT with RET.
FILAUX:	ld	(hl),0C9h
	inc	hl
	djnz	FILAUX
;
; Build DOS1 compatible PRTBUF routine (at the moment)
;
	ld	a,0CDh		;"CALL $DOSON"
	ld	hl,$DOSON##
	ld	(PRTBUF##),a
	ld	(PRTBUF##+1),hl
	ld	a,0C3h		;"JP _PRTBUF"
	ld	hl,_PRTBUF
	ld	(PRTBUF##+3),a
	ld	(PRTBUF##+4),hl
;
	ld	hl,ERR_MSG##	;Record address of
	ld	($ERR_MSG##),hl	; error message routine.
	ld	hl,PROMPT	;Record address of
	ld	($PROMPT##),hl	; disk change prompt routine.
	ld	hl,BDOS_GO##
	ld	($BDOS##),hl
	ld	hl,DOS1_GO##
	ld	($DOS1##),hl
;

MSXVER	equ	002Dh

	ld	a,(MSXVER)
	or	a
	jr	z,NOCLOCK
	ld	a,-1		;say clock IC is present
	ld	(TIMFLG##),a
NOCLOCK:
;
	ld	hl,DPBSIZE	;Allocate DPB for RAM disk
	call	PALLOC
	ld	(RM_DPB##),hl
;
	ld	hl,(MAXSEC)	;Get maximum sector size declared so far
	ld	de,R_SECLEN##
	COMPAR
	jr	nc,R_BIG	;Big enough to hold RAM disk sector
	ex	de,hl		;RAM disk is bigger, overwrite it
R_BIG:	ld	($MAXSEC##),hl
;
;	Allocate sector buffer for physical driver.
;
	inc	hl		;For DOS1 compatible "FAT dirty flag"
	call	PALLOC
	ld	(hl),0		;Fake FAT is clean.
	inc	hl
	ld	($SECBUF##),hl
;
	ld	hl,$DPBLIST##-2	;Start from RAM disk DPB
	ld	bc,256*(1+MAXDRV)+0FFh
ALCFAT:
	ld	e,(hl)		;get address of DPB for the drive
	inc	hl
	ld	d,(hl)
	inc	hl
	ld	a,e
	or	d
	jr	nz,YES_DPB

	push	bc	;If drive not in use, try to allocate
	push	hl	;space for a new DPB (for MAPDRV function)
	ld	hl,DPBSIZE
	call	ALLOC##
	ex	de,hl
	pop	hl
	pop	bc
	jr	c,NO_DPB
	dec	hl
	ld	(hl),d
	dec	hl
	ld	(hl),e
	inc	hl
	inc	hl
	inc	de
	xor	a
	ld	(de),a	;Reset media byte
	dec	de

YES_DPB:
	ex	de,hl		;Move address of DPB to [HL]
	ld	(hl),c		; set DRVNUM
	push	bc
	ld	bc,FAT
	add	hl,bc		;Point to end of DPB and
	ld	bc,($SECBUF##)	; store a pointer to the dummy
	ld	(hl),c		; FAT buffer there.
	inc	hl
	ld	(hl),b
	pop	bc
	ex	de,hl		;restore pointer to $DPBLIST
NO_DPB:
	inc	c		;bump DRVNUM
	djnz	ALCFAT
;
	call	GSLOT2		;Get current page-2 slot
	ld	b,a

	ld	a,(PROCNM+7)
	cp	1
	jr	z,NODOSINIT
	ld	a,b
	call	DOSINIT##	;Initialize disk-system
	jp	c,PANIC_INIT		;Something was wrong
	jr	OKDOSINIT
NODOSINIT:
	ld	a,b
	ld	(RAMAD3##),a
	ld	(RAMAD2##),a
	ld	(RAMAD1##),a
	ld	(RAMAD0##),a
OKDOSINIT:

;
if 1 ;These buffers should be permanent.  [HF]

	ld	hl,LEN_1##+LEN_2##+LEN_3##+64
	call	PALLOC
	ld	(BUF_1##),hl	;Allocate space for the buffers for strings,
	ld	de,LEN_1##	; FIB's, FCB's and error message in BDOS_GO.
	add	hl,de
	ld	(BUF_2##),hl
	ld	de,LEN_2##
	add	hl,de
	ld	(BUF_3##),hl
	ld	de,LEN_3##
	add	hl,de
	ld	(ERR_BUF##),hl
;
endif
	ld	hl,(HIMEM##)	;save HIMEM
	ld	(HIMSAV##),hl	;
;
	ld	hl,H.TIMI	;Save the current setting of
	push	hl		; the timer interrupt hook
	ld	de,TIMI_SAVE##	; in our data area.
	ld	bc,5
	ldir
;===== start add DOS2.50 (support MegaSCSI)
	ld	hl,_TIME_IRQ##
	ld	de,@TIME_IRQ##
	call	MYHOOK
;===== end add DOS2.50
	pop	hl		;Now set up an inter-slot call

	;This "patch for MegaSCSI" was causing the kanji mode to not work
	;(CALL KANJI hanging the computer)
	;since the Kanji ROM timer interrupt routine assumes that the
	;previous hook is either a RET or a RST 30h (not a CALL!)
if 0
;===== start mod DOS2.50 (support MegaSCSI)
	ld	de,_TIME_IRQ##	; to our timer interrupt
	ld	(hl),0;NOP	; routine in this ROM page.
	inc	hl
	ld	(hl),0CDh;CALL
	inc	hl
	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl
	ld	(hl),0C9h;RET
else
	ld	de,@TIME_IRQ##
	call	MYHOOK
endif

;;	ld	de,@TIME_IRQ##
;;	call	MYHOOK
;===== end mod DOS2.50
;
;	Establish extended BIOS hook
;
	ld	hl,FCALL	;Chain previous hook to us
	ld	de,FCALSAV##
	ld	bc,5
	push	hl
	ldir
	pop	hl
	ld	de,@EXTBIO##	;Set our new hook
	call	MYHOOK
;
;	Prepare for disk BASIC
;
	call	SETHOOKS##	;set up hooks for disk BASIC
;
;	set default screen size
;
	ld	hl,PRTTTL+7	;get higher address of INIT??
	ld	a,(EXPTBL##)
	call	RDSLT
	push	af		;save it
	inc	sp
	dec	hl		;get lower address of INIT??
	ld	a,(EXPTBL##)
	call	RDSLT
	push	af
	inc	sp
	pop	ix		;set address
	ld	iy,(EXPTBL##-1)	;load expanded flag to [IYH]
	call	CALSLT		;set default screen size
;
	call	PBAS_HOOK
;
if 1
	ld	sp,BOOTAD+512	;set stack pointer to a safe area
endif
if (HYBRID OR STURBO)
	ld	a,(PROCNM+7)
	cp	1
	jp	z,OLDDOS
	call	CHECK_1KEY	;If "1" or "2" key is pressed, kick MSX-DOS1.
endif
;
;	See if H.STKE has been set.  If so pass control to this hook
;
	ld	a,(H.STKE)
	cp	0C9h
;
WATLOP	equ	7D0Dh
;
	ld	ix,WATLOP+10	;hook set, get back to where we once
	jr	nz,GO_BASIC	;belonged
;
;	See if entered from TEXT entry of ROM cartridge
;
if 0
WORKOK	equ	7E09h
;
	ld	ix,WORKOK+11	;where we once belonged
	ld	hl,SLTATR##
	ld	b,64
SRCBAS:
	ld	a,(hl)
	add	a,a
	jp	c,CALBAS	;BASIC cartridge found
	inc	hl
	djnz	SRCBAS
else
SRCBAS	equ	7DEEh
BASROM	equ	0FBB1h
;
	ld	a,(BASROM)
	or	a
	ld	ix,SRCBAS-5	;Because BASIC cartridge is no more enabled.
	jr	nz,GO_BASIC
endif
	call	CANCEL_XFER
;===== start mod DOS2.50 (build type)
if BUILTIN
;;if HYBRID
;===== end mod DOS2.50
	ld	a,(RAMAD3##)
	ld	(RAMAD2##),a
endif
	jr	NO_TEXT
;
GO_BASIC:
	call	CHECK_BAS2	;See if we can start Disk-BASIC 2.
;
;******************************************************************************
if 1
; For 'EMMY II' and 'Professional Baseball' (by ASCII).
; THIS MUST BE AT OFFSET -10H FROM RETURN ADDRESS OF 'CALL JP_BOOT'.
;
	call	SET_DISKBASIC
endif
;******************************************************************************
;
	jp	CALBAS
;
;	Read the boot sector and pass control
;
NO_TEXT::
	ld	hl,BASIC		;Set jump address when MSXDOS cannot
	push	hl			; start.

	ld	a,(BOOT_DRV##)
	or	a
	jr	nz,FASTBOOT

	call	READ_BOOT_SEC##		;Attempt to read the boot sector and
	ret	z			; give up if could not read one.

if HYBRID
	call	BSEC_TYPE
	or	a
	jp	z,OLDDOS	;If DOS 1 boot sector, switch DOS 1
	dec	a
	scf
	ccf
	call	z,JP_BOOT_SEC	;If DOS 2.20 sector, call sector code with NC (???)
else
;===== start mod FAT16 (DOS2.50 original patch)
	call	BSEC_TYPE
	cp	2
	scf
	ccf
	call	nz,JP_BOOT_SEC		;Call the boot sector with carry clear.
;;	call	JP_BOOT_SEC
;===== end mod FAT16
endif
;
	ld	hl,(BOTTOM##)		;If RAM is not available down
	ld	de,8000h		; to the bottom of page-2
	COMPAR				; then dive into BASIC as we
	ret	nz			; cannot boot up MSX-DOS.
;
	ld	a,(CUR_DRV##)
if 1
FASTBOOT:
endif
	ld	hl,NULL_CMD

;
; HL = null terminated command line.
;
REBOOT::
	ld	a,(BOOT_DRV##)

	ld	sp,BOOTAD+512		;Must have stack in safe place.
	push	hl
	ld	hl,BASIC		;Set jump address when MSXDOS cannot
	ex	(sp),hl			; start.
;
	push	af
	ld	a,0FFh			;Say we're running MSXDOS
	ld	(DOSFLG##),a		; just for compatibility reason.
	pop	af
;
	call	TRYBOOT##		;Try to boot up MSX-DOS 2.
;
	ld	a,(NOTFIRST##)		;If it failed and this is the reboot
	or	a			; don't try to boot up from the boot
	ret	nz			; sector.
;
	call	TO_BASIC_REQUIRED
	ret	z

	call	READ_BOOT_SEC##		;Attempt to read the boot sector and
	ret	z			; give up if could not read one.
;
;===== start mod DOS2.50 (build type)
if HYBRID
;;if 1 ;HYBRID
;===== end mod DOS2.50
	call	BSEC_TYPE		;If this is not the MSX-DOS2 2.20/2.3x media
	cp	1
	ret	nz			; don't attempt to reboot.
;
endif
	ld	a,0C3h			;Enable $DOSON, $DOSOFF and XFER
	call	SET_XFER		; then call the boot sector with
	scf				; carry flag set to boot up MSXDOS.
;
    jp JP_BOOT_SEC

	subttl	Set up for disk BASIC

IPLSTR:
	defb	'RUN',34,'\AUTOEXEC.BAS'
NULL_CMD:
	defb	0
NEW_CMD:
	defb	'NEW',0
IPLLEN	equ	$-IPLSTR
;
POPHL	equ	BUF+10		;"POP HL" and "RET"
RUNSTR	equ	POPHL+2
IPLNAME	equ	RUNSTR+4
;
NOIPLVECT:
	defw	NOIPL
;
;	Invoke disk BASIC
;
BASIC::
	ld	sp,BOOTAD+512	;Set stack pointer to a safe area
;
	call	CANCEL_XFER	;Kill $DOSON, $DOSOFF and XFER
;
	ld	hl,IPLSTR	;transfer 'RUN"AUTOEXEC.BAS' string
	call	TO_BASIC_REQUIRED
	jr	nz,BASIC2
	ld	hl,NEW_CMD
BASIC2:
	ld	de,RUNSTR
	ld	bc,IPLLEN
	ldir
;
	ld	hl,NOTFIRST##
	ld	a,(hl)
	or	a		;first time?
	ld	(hl),h		;set this since seen
	jr	nz,FROMDOS	;no, DOS is calling me
;
	ld	(DOSFLG##),a	;reset DOS flag
	ld	hl,NOIPLVECT	;set error trap
	ld	(DISKVECT##),hl
;
	ld	de,IPLNAME
	ld	a,1		;Read-only
	ld	c,_OPEN##
	call	BDOS##
	jr	nz,NOIPL	;"AUTOEXEC.BAS" does not exist
	ld	c,_CLOSE##
	call	BDOS##		;File handle in [B] is intact
;
	jr	BASIC1		;execute "AUTOEXEC.BAS"
;
;	Invoke Disk BASIC from DOS.
;
FROMDOS:
	ld	a,(0)
	cp	0C3h		;instruction code for "JP"
	jr	nz,NOIPL1	;no, cannot be MSXDOS
	ld	hl,80h
	ld	b,(hl)		;get length of command line
	inc	b		;any argument?
	dec	b
	jr	z,NOIPL1	;no
;
IGNORE_BLANK:
	inc	hl
	ld	a,(hl)
	call	ISBLANK		;blank?
	jr	nz,NOT_BLANK	;no
	djnz	IGNORE_BLANK
	jr	NOIPL1		;all was blank, no argument
;
ISBLANK:
	cp	TAB
	ret	z
	cp	" "
	ret
;
NOT_BLANK:
	xor	a
	ld	c,b
	ld	b,a
	ld	de,RUNSTR+4
	ldir
	ld	(de),a		;put terminator
	jr	BASIC1
;
NOIPL:
NOIPL1:	xor	a
	ld	(RUNSTR+3),a	;terminate the "RUN" string
;
BASIC1:	ld	sp,BOOTAD+512	;set stack pointer to a safe area
;
	ld	a,(RAMAD2##)	;enable possible RAM at page-2
	ld	h,80h
	call	ENASLT
	ld	a,(EXPTBL##)	;enable ROM at page-0
	ld	h,0
	call	ENASLT
;
	call	SET_DISKBASIC	;set up for Disk BASIC
;
rejoin:	ld	bc,0*256+_JOIN##;Reset file handles etc.
	call	BDOS
	jr	nz,rejoin
;
	ld	hl,(BOTTOM##)
	xor	a
	ld	(hl),a
	inc	hl
	ld	(TXTTAB),hl
	ld	(hl),a
	inc	hl
	ld	(HL),a
	inc	hl
	ld	(VARTAB),hl
	ld	hl,-1		;say we're in direct mode
	ld	(CURLIN),hl
	ld	sp,(STKTOP)

	ld	a,-1		;display function key
	ld	(CNSDFG),a
;
	ld	ix,PRTTTL+8	;print copyright message
	call	CALBAS
if NEW
	call	PRT_CRLF
	ld	de,_$DSKBASIC
	call	MSG_DE
	call	PRT_CRLF
else
;
; ARABIC OS calls here.
;
	call	STROUT
	defb	CR,LF,"Disk BASIC version 1.0",CR,LF,0
endif
	ld	hl,INILIN	;set jump address
	push	hl
	ld	hl,RUNSTR-1
	push	hl		;set text pointer
	ld	hl,POPHL
	push	hl
	ld	(hl),0E1h	;"POP HL"
	inc	hl
	ld	(hl),0C9h	;"RET"
	ld	a,(EXPTBL##)	;enable ROM at 4000h..7FFFh
	ld	h,40h
	jp	ENASLT

;
;	Set up environments for disk BASIC
;
SET_DISKBASIC::
	ld	hl,(HIMSAV##)	;restore real HIMEM
	ld	(HIMEM##),hl
;
	call	DB_INIT##	;setup BDOS for Disk BASIC
;
	ld	hl,DBERR##
	ld	(DISKVECT##),hl
	ld	hl,DBABORT##
	ld	(BREAKVECT##),hl
;
	ld	bc,($MAXSEC##)	;Allocate sector buffer for DSKI$, DSKO$
	call	RESERVE_BASIC
	ld	($DIRBUF##),hl
if 0
;
	ld	bc,64		;Allocate space for the
	call	RESERVE_BASIC	; pathname buffer.
endif
	ld	(PATHNAM##),hl	;Reuse this as Disk BASIC's pathname buffer
;
;	Set BLOAD and BSAVE routine
;
	ld	bc,BLOAD_BSAVE_LEN
	call	RESERVE_BASIC
	call	SET_BLOAD_BSAVE
;
	call	DEFILE##	;re-define file structure
CANCEL_XFER:
	ld	a,0C9h		;cancel $DOSON, $DOSOFF and XFER
SET_XFER:
	ld	($DOSON##),a
	ld	($DOSOFF##),a
	ld	(XFER##),a
	ret

SET_BLOAD_BSAVE:
	ld	(BLDCHK##),hl
	ex	de,hl
	ld	hl,BLOAD_DATA
	ldir
	ld	hl,BSAVE_DATA - BLOAD_BSAVE_END
	add	hl,de
	ld	(BSVCHK##),hl
	ld	a,(MASTER_SLOT##)
	ld	hl,BLOAD_SLOT - BLOAD_BSAVE_END
	add	hl,de
	ld	(hl),a
	ld	hl,BSAVE_SLOT - BLOAD_BSAVE_END
	add	hl,de
	ld	(hl),a
	ret
;
;	RESERVE_BASIC reserves specified  amount  of  memory  down  from
;	current  HIMEM.  It differs from ALLOC in that DOS variables are
;	overwritten.  Solely called when MSX-DISK BASIC starts up.
;
; Inputs:
;	BC = memory size to reserve
; Outputs:
;	If successful, HL is pointing to the beginning of reserved
;		       area.
;	Otherwise, jumps into PANIC.
;
RESERVE_BASIC:
	ld	hl,(HIMEM##)
	or	a
	sbc	hl,bc
	ld	(HIMEM##),hl
CHECK_PANIC:
	jp	c,PANIC_HIMEM
	ld	a,h
	cp	0C2h
	jr	PALLOC1
;
PALLOC:
	call	ALLOC##
PALLOC1:
	ret	nc		;successfully allocated
;
;
;	See if H.CLEA has been set.  If so intercept at H.LOPD.
;
PBAS_HOOK:
	ld	hl,H.CLEA	;PBAS?
	ld	a,(hl)
	cp	0C9h
	ret	z
	ld	hl,H.LOPD
	ld	de,SAVE_HIMEM
	;	;
	;	;
;
;	Set a hook directed to us.
;
;	HL = Hook address
;	DE = Entry
;
MYHOOK:
	ld	(hl),0F7h	;"RST 30h" (far-call) instruction
	inc	hl
	ld	a,(MASTER_SLOT##)
	ld	(hl),a		;My slot address
	inc	hl
	ld	(hl),e		;Jump entry low
	inc	hl
	ld	(hl),d		;Jump entry high
	inc	hl
	ld	(hl),0C9h	;"RET" instruction
	ret

;
;   Following code is to fix the "PBAS" problem (preserves BC,HL)
;
SAVE_HIMEM:
	ld	a,0C9h		;cancel hook
	ld	(H.LOPD),a
	ld	de,(HIMEM##)	;save HIMEM set by PBAS
	ld	(HIMSAV##),de
	ret

	subttl	Copies of RAM routines for disk BASIC
;
;	Instructions which should be transferred to RAM to check BLOAD
;	or BSAVE to disk.
;
BLOAD_DATA:
	rst	30h
BLOAD_SLOT:
	defb	0		;dummy
	defw	BLOAD##
	push	hl		;save text pointer
	jp	CHKBRN		;run if "R" option specified
;
BSAVE_DATA:
	rst	30h
BSAVE_SLOT:
	defb	0		;dummy
	defw	BSAVE##
	ret
;
BLOAD_BSAVE_END:
;
BLOAD_BSAVE_LEN equ	$-BLOAD_DATA

	subttl	Master functions
;
;	PHYDIO hook is directed to here.
;
; Inputs:
;	[F]  = Carry flag reset for read,
;			    set for write.
;	[A]  = Drive number (starts at 0).
;	[B]  = Number of sectors to read/write.
;	[C]  = Media descriptor (ignored???).
;	[DE] = Logical sector number (starts at 0).
;	[HL] = Transfer address.
;
; Outputs:
;	if successful, carry flag reset,
;	otherwise,     carry flag set,
;		       error code is placed in [A],
;		       number of remaining sectors in [B].
;
	public	DSKRW
DSKRW:
	ei			;Re-enable interrupt because I was
				; inter-slot called.
	push	hl		;save target address
	push	af		;save R/W flag
	call	MAPDRV
	jr	c,DSKRW1	;Found the proper entry
	scf
	ld	a,12		;Some sort of "other errors"
	pop	hl
	pop	hl
	ret
DSKRW1:
	ld	l,a		;save physical drive number
	pop	af		;restore R/W flag
	ld	a,l		;set physical drive number
	pop	hl		;Restore transfer address
	push	hl		;Save it again
	ld	ix,DKRWENT##	;DSKRW entry address
if HYBRID
	call	GO_DRV##
else
	call	CALSLT
endif
	pop	hl		;Restore transfer address
	ret
;
;	Maps logical drive number to physical drive number
;
MAPDRV:
	push	bc
	ld	(TARGET),a	;Save target drive (0 based)
	ld	hl,DRVTBL
	ld	b,MAXCARD
MAPDR1:
	sub	(hl)		;Subtract number of drives assigned
				; to this cartridge
	jr	nc,MAPDR2	;Not yet found the target slot
	add	a,(hl)		;Make value to pass to physical driver
	inc	hl
	ld	h,(hl)		;Set slot address to [IYH]
	push	hl
	pop	iy
	pop	bc
	ret
MAPDR2:
	inc	hl
	inc	hl
	djnz	MAPDR1
	pop	bc
	ret
;
;	MTOFF entry is directed to here.
;
	public	$MTOFF
$MTOFF:
	ld	hl,DRVTBL
	ld	b,MAXCARD
MTOFF_LOOP:
	inc	hl
	ld	a,(hl)		;get slot address
	push	af		;copy it to IYH
	pop	iy
	inc	hl
	push	hl		;save pointer to table
	push	bc		;save counter
	ld	hl,MTOFFENT##
	push	hl
	pop	ix
	or	a		;slot address 0?
	call	nz,RDSLT	;no, read entry
	or	a		;entry there?
if HYBRID
	call	nz,GO_DRV##
else
	call	nz,CALSLT	;yes, call it
endif
	pop	bc		;restore counter
	pop	hl		;save pointer to table
	djnz	MTOFF_LOOP	;more entries remain
	ret
;
;------------------------------------------------------------------------------
;
TIMINT::
	push	af	;Save VDP status
	ld	a,(DOS_VER##)
	or	a
	jr	nz,DOS2INT

	;Interrupt handler, DOS 1 version

	call	TIMI_250	;Call 2.50 kernels driver interrupt routine.
	ex	af,af'
	pop	af		;Restore VDP status
	ex	af,af'
	ld	a,3
	ld	ix,PRV1INT##
	jp	CALBNK##

	;Interrupt handler, DOS 2 version

DOS2INT:
	call	TIME_IRQ##	;Call the master interrupt routine.
	call	TIMI_DRV	;Call driver interrupt routine in turn.
	call	TIMI_250	;Call 2.50 kernels driver interrupt routine.
	pop	af		;Restore VDP status
	jp	TIMI_SAVE##

TIMI_DRV:
;
;	Call all possible disk drivers interrupt which is combined with
;	new DOS2 code. This is because the disk drivers entry may not
;	be revealed at this point (because of local banking)
;
	ld	de,DRVTBL
	ld	hl,HOOKSAV
	ld	b,MAXCARD
scan_loop:
	ld	a,(de)		;Get number of drives
	and	a		; no drives?
	ret	z		; yes, done

	inc	de
	ld	a,(de)		;Get slot address
	inc	de
	cp	(hl)		; same?
	jr	nz,next_cart	; no, this has been set by
				; old SETINT
	ld	a,(MASTER_SLOT##)
	cp	(hl)		;Is it me?
	ld	a,(hl)		; assume not
	push	bc		; save count
	push	de		;  DRVTBL pointer
	push	hl		;  HOOKSAV pointer
	inc	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	push	af
	pop	iy
	push	de
	pop	ix
	call	call_drv
	pop	hl
	pop	de
	pop	bc
next_cart:
	inc	hl
	inc	hl
	inc	hl
	djnz	scan_loop
	ret
;
call_drv:
	jp	nz,CALSLT	;Was slave, call thru inter-slot call
	jp	(ix)		;Was me, just call my slot.
;
;
TIMI_250:
;
;       Call the interrupt routine of DOS 2.50 kernels
;
	ld	hl,KER250
	ld	b,4
T250_LOOP:
	ld	a,(hl)
	bit	6,a	;Zero if empty entry or if no interrupt declared
	jr	z,T250_DJNZ

	push	hl
	push	bc
	and	10001111b
	db	0FDh,67h	;LD IYh,A
	ld	a,(MASTER_SLOT##)
	db	0FDh,0BCh	;CP IYh
	db	0FDh,7Ch	;LD A,IYh
	ld	h,40h
	ld	ix,DV_TIRQ##
	call	call_drv
	pop	bc
	pop	hl

T250_DJNZ:
	inc	hl
	djnz	T250_LOOP
	ret

;
	;public	PROMPT
PROMPT:
	ld	a,(TARGET##)	;get 0 based target drive number
	add	a,"A"		;make a drive name
;
	call	H.PROMPT##
;
	push	af		;save drive name
	call	PRT_CRLF
	ld	a,__PRM1##	;"Insert disk for drive".
	call	PRT_ROM_MSG
	pop	af
	call	$OUT
	ld	a,__PRM2##	;":" after drive name.
	call	PRT_ROM_MSG
	call	PRT_CRLF
	ld	a,__PRM3##	;"and strike a key when ready ".
	call	PRT_ROM_MSG

PROMPT_WAIT:
	call	GET_CHAR	;wait for response
	jr	z,PROMPT_WAIT	;ignore ctrl-C
;
	jp	PRT_CRLF	;put newline and return

GET_CHAR:
	call	_GET_CHAR
	cp	3		;return with Z if abort
	ret

PRT_ROM_MSG:
	push	hl
	push	de
	ld	de,($SECBUF##)
	call	ROM_MSG##
	call	MSG_DE
	pop	de
	pop	hl
	ret

MSG_DE:
	ld	a,(de)
	inc	de
	or	a
	ret	z
	call	$OUT
	jr	MSG_DE

_GET_CHAR:
;**DOS2 	xor	a		;invalidate KEYCHR
;**DOS2 	ld	(KEYVLD),a
	push	ix
	push	hl
	ld	ix,KILBUF	;flush input buffer
	call	CALROM
	pop	hl
	ld	ix,CHGET
	jr	IN_OUT

; $OUT outputs code on screen (all registers are preserved).
$OUT:
	push	ix
	ld	ix,CHPUT
IN_OUT:
	call	CALROM
	pop	ix
	ret

CALROM:
	push	iy
	ld	iy,(EXPTBL##-1)
	call	CALSLT
	ei			;make sure interrupt is enabled
	pop	iy
	ret
;
;	Get entry address into SLTWRK.  Result returned in [HL].
;	Preserves [DE].
;
GET_SLTWRK_ENTRY:

if 1
	xor	a
	call	GWRK
	push	ix
	pop	hl
	ret
else
	in	a,(PPI.AR)	;read primary slot #
	and	00001100b	;extract page-1
	rrca			;move it to bit 0,1 of [Acc]
	rrca
	ld	hl,EXPTBL##	;get pointer to EXPTBL for this slot
	call	ADDHLBC
	add	a,a
	add	a,a
	add	a,a
	add	a,a
	inc	a
	ld	c,a		;[C] now has 00PP0001
	ld	a,(hl)
	add	a,a
	sbc	a,a		;form mask pattern
	and	00001100b
	inc	hl		;point to SLTTBL entry
	inc	hl
	inc	hl
	inc	hl
	and	(hl)		;get what is currently output to
				;expansion slot register
	or	c
;
;	Now, we have the sequence number for this cartridge as follows.
;
;	00PPSSBB
;	  ||||||
;	  ||||++-- higher 2 bits of memory address
;	  ||++---- secondary slot # (0..3)
;	  ++------ primary slot # (0..3)
;
	add	a,a		;double since word table
	ld	hl,SLTWRK##	;point to entry in SLTWRK table
endif

ADDHLBC:
	ld	c,a
	ld	b,0
	add	hl,bc
	ret

;
;	Define disk driver's timer interrupt entry
;
;	HL = timer interrupt entry address
;
	public	SETINT
SETINT:
	ex	de,hl		; de = interrupt entry
	call	GSLOT1##
	push	af		; save slot number
	call	GET_DISKID_HL
	ld	a,(hl)	;(DISKID)	; make a pointer to HOOKSAV
	ld	hl,HOOKSAV
	call	ADDHLBC
	add	hl,bc
	add	hl,bc
	pop	af
	ld	(hl),a
	inc	hl
	ld	(hl),e
	inc	hl
	ld	(hl),d
;
;	Return from disk driver interrupt (was jump to previous hook in DOS1)
;
	public	PRVINT
PRVINT:
	ret

;
;-----------------------------------------------------------------------
;
; These  routines return the slot address of the currently selected slot
; for the page specified by the entry.  To keep it as quick as possible,
; each  page  is  handled as a special case, although this does make the
; code rather large.  All registers except AF are preserved.
;
; Get slot address for page 0
GSLOT0::
	push	hl
	push	bc
	in	a,(PPI.AR)	;Get primary slot register
				;Isolate primary slot number
				; for page-0.
	call	GSLT_SLTTBL
	jr	z,GSLT_RET	;Slot is not expanded.
	rlca
	rlca
	jr	GSLT_EXP

; Get slot address for page 1
GSLT1::
	push	hl
	push	bc
	in	a,(PPI.AR)	;Get primary slot register
	rrca			;Isolate primary slot number
	rrca			; for page-1.
	call	GSLT_SLTTBL
	jr	z,GSLT_RET	;Slot is not expanded.
	jr	GSLT_EXP	;Form whole address.

; Get slot address for page 2
GSLOT2::
	push	hl
	push	bc
	in	a,(PPI.AR)	;Get primary slot register
	rrca
	rrca
	rrca			;Isolate primary slot number
	rrca			; for page-2.
	call	GSLT_SLTTBL
	jr	z,GSLT_RET	;Slot is not expanded.
	jr	GSLT_EXP2

;       Get slot address for page 3
GSLOT3::
	push	hl
	push	bc
	in	a,(PPI.AR)	;Get primary slot register

	rlca			;Isolate primary slot number
	rlca			; for page-3.
	call	GSLT_SLTTBL
	jr	z,GSLT_RET	;Slot is not expanded.
	rrca
	rrca
GSLT_EXP2:
	rrca
	rrca
GSLT_EXP:
	and	00001100b	;Isolate secondary slot bits
	or	10000000b	;Set "expanded slot" flag
	or	c		;Include primary slot.
;
GSLT_RET:
	pop	bc
	pop	hl
	ret

GSLT_SLTTBL:
	and	00000011b
	ld	c,a
	ld	b,0
	ld	hl,EXPTBL##
	add	hl,bc		;Look at expanded slot flag
	bit	7,(hl)		; for this slot and return
	ret	z		; if slot is not expanded.
;
	inc	hl
	inc	hl
	inc	hl		;Get current secondary slot
	inc	hl		; register value for this
	ld	a,(hl)		; slot
	ret

	subttl	Disk Formatter

	;Formatting code moved to the end of the file
	;since it wrapped at 4FB8h (see ALIGN below).

	PRINTL	INIT,%($-$$INIT)


    ;Scan and store boot keys and check if keyboard is Russian if that hasn't been done yet

DO_KEYS_INIT:
    call CHECK_IS_RUSSIAN
    ld (I_AM_RUSSIAN##),a

    call SCANKEYS_RAM
    jr z,DO_KEYS_INIT2
    call SCANKEYS
    
    ld a,(KEYS_INV_0)
    and 00111110b
    xor b
    ld b,a

    ld a,(KEYS_INV_1)
    and 00110000b
    xor h
    ld h,a
  
DO_KEYS_INIT2:
    ld a,b
    ld (BOOTKEYS##),a
    ld (BOOTKEYS##+1),de
    ld (BOOTKEYS##+3),hl

    ret


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	End of hole.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	subttl	MSX-DOS1 compatible ROM entries (part 2)
;
	ALIGN	4FB8h
SFIRST:	CALLDOS	11h	;;Search for first (FCB)
;

SET_DPBS:
	ld	(PROCNM+6),a
	ld	(de),a		;set number of drives in DRVTBL
	inc	de
	call	GSLOT1##	;get slot address in [A]
	ld	(de),a		;set slot address in DRVTBL
	ld	b,0		;[BC] = offset into $DPBLIST
	ld	hl,$DPBLIST##
	add	hl,bc		;double since word table
	add	hl,bc
	push	hl		;save pointer to $DPBLIST
	dec	de
	ld	a,(de)		;re-get number of drives assigned to
				;this cartridge
	push	af		;save number of drives assigned
	ld	c,a		;[BC] = number of drives assigned
	add	a,a		;number of drives * 2
	add	a,a		;number of drives * 4
	add	a,c		;number of drives * 5
	add	a,a		;number of drives * 10
	add	a,a		;number of drives * 20
	add	a,c		;number of drives * 21
	ld	l,a		;[HL] = total size of DPB's
	ld	h,b		;
	call	PALLOC		;if unable to allocate DPBs, no way...
	ex	de,hl		;[DE] = base of DPB for this cartridge
	pop	af		;restore number of drives assigned
	pop	hl		;restore pointer to $DPBLIST
SETDEFDPB:
	ld	(hl),e		;set pointer to DPB
	inc	hl
	ld	(hl),d
	inc	hl
	push	hl		;save pointer to $DPBLIST
	ld	hl,DEFDPB##	;-1 is for DRVNUM (removed since DEFDPB
	ld	bc,DPBSIZE	; already points to DPB-1)
	ldir			;set up default DPB for this cartridge
	pop	hl		;restore pointer to $DPBLIST
	dec	a		;more drives assigned?
	jr	nz,SETDEFDPB	;yes
	ret

	ALIGN	5006h
SNEXT:	CALLDOS	12h	;;Search for next (FCB)
;

; Compare zero terminated strings pointed by HL and DE
; Return Z if they are equal, NZ if not
; Modifies AF, HL, DE

STRCOMP:
    ld	a,(de)
	cp	(hl)
	ret	nz
	or	a
	ret	z
	inc	hl
	inc	de
	jr	STRCOMP

	ALIGN	501Eh
FSIZE:	CALLDOS	23h	;;Get file size (FCB)
;

    ;--- Get in A the number of drives assigned to this driver at boot time.

COUNTDRV:
	ld a,(PROCNM+10)
	ld b,a
	ld	hl,DRVS2##
	ld	(BK4_ADD##),hl
	call	?C4PBK##
	ret

JP_BOOT_SEC:
    call SBDAVEC##

	ld	hl,DISKVECT##		;Jump into the MSX-DOS boot code
	ld	de,$DOSON##		; with necessary parameters in hand.
	ld	a,(NOTFIRST##)
	jp	BOOTAD+1Eh

	ALIGN	504Eh
LOGIN:	CALLDOS	18h	;Get login vector
;
	ALIGN	5058h
SETDTA:	CALLDOS	1Ah	;Set disk transfer address
;
	ALIGN	505Dh
GETDPB:	CALLDOS	1Bh	;Get allocation information
;
;
;	Validate DRVTBL
;
VALTBL:
	ld	hl,DRVTBL
	ld	b,MAXCARD
	xor	a
	ld	e,a
CALDR1:
	ld	c,a
	add	a,(hl)
	jp	c,PANIC_TOOMD
	cp	c
	jr	z,CALDR2	;this entry is empty
	inc	e
	inc	hl
	inc	hl
	djnz	CALDR1
	cp	a		;Z flag set ==> No room left
	ret			;		(for new cartridges)
CALDR2:
	add	a,(hl)
	cp	c
	jp	nz,PANIC_NOEMP	;rest of the entries should be empty
	inc	hl
	inc	hl
	djnz	CALDR2
;
	cp	MAXDRV
	ret	z		;no room left (for new drives)
	ret	c
;
;JP_PANIC:
;
;	system area has been crashed
;	This should not be a "No enough memory" message!!
;
	jp	PANIC_TOOMD		;system area has been crashed

	ALIGN	509Fh
DSKRST:	CALLDOS	0Dh	;Disk reset
;
	ALIGN	50A9h
WRTFAT:	ld	bc,256*0FFh+5Fh		;Just flush disk buffers of all
	ld	d,0			; drives.
	jp	GO_DOS2
;
	ALIGN	50C4h
GETDRV:	ld	c,19h	;Get current drive
	jr	SETRND+2		;alas there's no ROM space here.
;
	ALIGN	50C8h
SETRND:	CALLDOS	24h	;;Set random record (FCB)
;
	ALIGN	50D5h
SELDSK:	CALLDOS	0Eh	;Select disk
;
	ALIGN	50E0h
BUFIN:	CALLDOS	0Ah	;;Buffered line input
;
	ALIGN	5183h
CRLF:	ld	e,CR
	call	CONOUT
	ld	e,LF
	jp	CONOUT
;
;   About 450 bytes hole here.
;
if HYBRID
; 
CHECK_1KEY:
    ld a,(BOOTKEYS##) ;If "1" or "2" key is pressed at THIS (oops) moment, force MSX-DOS1
    and 00000110b
;===== start mod DOS2.50 (build type)
	jr	nz,OLDDOS	;OLDDOS will do the rest of work.

	ld	a,(IN_EMU##)	;If in disk emulation mode (set by AUTODRV from DOSINIT),
	or	a               ;switch to DOS 1 mode
	jr	nz,OLDDOS

if STURBO
	ld	a,(VERSION)
	cp	3		;MSXturboR?
	ret	c		;no
	ld	a,(BOOTKEYS##)	;4 key pressed?
	and	00010000b
	ld	a,81h
	jp	nz,CHGCPU
	ld	a,82h		; otherwise switch to "super turbo" mode
	jp	CHGCPU		; (lighting indicator also) and return.
else
	ret
endif
;;	ld	a,82h
;;	jp	nz,CHGCPU
;;	jr	OLDDOS
;===== end mod DOS2.50
;
; Comes here when H.STKE is set.  Start ROM application.
CHECK_BAS2:
	ld	hl,USRTAB		;If USRTAB != FCERR, then
	ld	a,(hl)			;  it knows there may be a DOS2.
	cp	low FCERR		;
	ret	nz			; So, set up Disk-BASIC 2.
	inc	hl			;
	ld	a,(hl)			;
	cp	high FCERR		;
	ret	nz			;
	pop	hl			;Adjust stack (not needed)
	jr	OLDDOS
;
;
OLDDOS::
	ld a,0C9h
	ld (H.PROMPT##),a
	ld (H.PROMPT##+1),a
	ld (H.PROMPT##+2),a

	ld	a,1
	ld	(PROCNM+7),a
	ld	a,3
	ld	(MAIN_BANK##),a

;===== start mod DOS2.50 (build type)
if STURBO
	ld	a,(VERSION)
	cp	3			;MSXturboR?
	jr	c,NOCHCPU

	ld	a,(BOOTKEYS##)  ;2 key pressed?
	and	00000100b
	ld	a,81h
	jr	nz,DOCHCPU
	ld	a,80h			;Insure CPU=Z80
DOCHCPU:
	call	CHGCPU
NOCHCPU:
endif
;;	ld	a,80h
;;	call	CHGCPU
;===== end mod DOS2.50
;
	ld	a,(RAMAD2##)		;Restore slot-2 in case of
	ld	h,80h			; BASIC text cartridge.
	call	ENASLT			;
;
	di				;Restore Hooks set by us
	ld	HL,TIMI_SAVE##		;
	ld	de,H.TIMI		; at H.TIMI
	ld	bc,5			;
	ldir				;
	ld	HL,FCALSAV##		;
	ld	de,FCALL		; at FCALL
	ld	bc,5			;
	ldir				;
;
	ld	hl,($MAXSEC##)		;Restore MAXSEC
	ld	(MAXSEC),hl		;
;
	ld	hl,(RM_DPB##)		;Restore HIMEM
	ld	de,DPBSIZE		;
	add	hl,de			;
	ld	(HIMEM##),hl		;
	call	DEFILE##		; and rebuild BASIC's FCB structure
	ld	sp,(STKTOP)		;
;
	;Begin of creation of DVB_TABLE

	xor	a
	ld	(DOS_VER##),a	;Needed for AUTODRV

	ld (0F242h),a  ;data buffer changed flag in DOS 1
	ld (0F23Bh),a  ;console output to printer flag in DOS 1

	;If we are in disk emulation mode (set by AUTODRV from DOSINIT),
	;the work area is already created in BUF_1,
	;so just jump to area relocation procedure.

	ld	a,(IN_EMU##)
	or	a
	jr	nz,MK_EMU_TBL

	;Build the table of drives attached to device-based drivers.
	;We call AUTODRV on segment 4 to build the table in a
	;fixed location (BUF_1), then we allocate space for the
	;table in page 3 and copy the table here, prepended by
	;a byte that tells how many entries are in the table.

	ld	hl,0F980h	;(BUF_1##)
	ld	(DVB_TABLE##),hl
	ld	hl,AUTODRV##
	ld	(BK4_ADD##),hl
	call	?C4PBK##

	jr	MK_DVB_TBL

MK_EMU_TBL:
	;We are in disk emulation mode.
	;If a explicit location was specified for the work area,
	;then just copy from BUF_1 to it.
	;Otherwise allocate space in page 3.

    ld hl,(EMU_WK_AREA##)
	ld	a,h
	or	l
	jr	nz,OK_EMU_WK

	ld	hl,16
	call	ALLOC##	;TODO: Check for failure to allocate

OK_EMU_WK:
	push	hl
	ex	de,hl
	ld	hl,EMU_TMP##
	ld	bc,16
	call	MEMCPY

	pop	hl
	set	7,(hl)	;Disk emulation mode flag

	ld	(DVB_TABLE##),hl

	jr	END_DVB_TBL

MK_DVB_TBL:
	ld	hl,0F980h	;(BUF_1##)
	ld	a,(hl)
	or	a
	jr	z,AUTODRV_OK2	;No drives for device-based drivers?

	ld	b,a	;B = Number of entries in the table
	add	a,a
	add	a,a
	add	a,a
	ld	l,a
	ld	h,0
	inc	hl	;HL = Size of table = (entries * 8) + 1
	push	hl
	call	ALLOC##
	pop	bc
	jr	z,AUTODRV_OK
	ld	hl,0
	ld	(DVB_TABLE##),hl
	jr	AUTODRV_OK2
AUTODRV_OK:

	ld	(DVB_TABLE##),hl
	ex	de,hl
	ld	hl,0F980h	;(BUF_1##)
	ldir

AUTODRV_OK2:

	;End of creation of DVB_TABLE

END_DVB_TBL:
	ld	hl,(KER250##)		;Preserve KER250 and DVB_TABLE since
	push	hl                      ;the next ldir will erase it
	ld	hl,(KER250##+2)
	push	hl
	ld	hl,(DVB_TABLE##)
	push	hl

	xor	a			;
	ld	(CUR_DRV##),a		;DIRTYDIR of MSX-DOS1
	ld	HL,TIM_RATE##		;LASTENT  of MSX-DOS1
	ld	(HL),A			;Clear LASTENT thru BREAKVECT
	ld	D,H			; of MSX-DOS1
	ld	E,L
	inc	DE
	ld	BC,AUXBODY##-TIM_RATE##-1
	ldir

	pop	hl
	ld	(DVB_TABLE##),hl
	pop	hl
	ld	(KER250##+2),hl
	pop	hl
	ld	(KER250##),hl
;
	ld	de,DRVTBL
	ld	hl,HOOKSAV
	ld	b,MAXCARD
olddos_0:
	ld	a,(de)
	or	a
	jr	z,olddos_9
	inc	de
	ld	a,(de)
	inc	de
	cp	(hl)			;Same?
	jr	nz,olddos_3		;No, set by old SETINT
;
	push	hl
	ld	hl,H.TIMI
	ld	a,(hl)
	sub	0C9h
	jr	nz,olddos_1
	ld	(hl),0F7h
	inc	hl
	ld	(hl),a			;No previous hook yet
	inc	hl
	ld	(hl),a
	inc	hl
	ld	(hl),a
	inc	hl
	ld	(hl),0C9h
olddos_1:
	pop	hl
	push	hl
	push	de
	push	bc
	ld	b,3
	ld	de,H.TIMI+1
olddos_2:
	ld	a,(de)
	ld	c,(hl)
	ld	(hl),a
	ld	a,c
	ld	(de),a
	inc	de
	inc	hl
	djnz	olddos_2
	pop	bc
	pop	de
	pop	hl
olddos_3:
	inc	hl
	inc	hl
	inc	hl
	djnz	olddos_0
olddos_9:

	ld	hl,FCALL	;Patch EXTBIO again
	ld	de,FCALSAV##
	ld	bc,5
	push	hl
	ldir
	pop	hl
	ld	de,@EXTBIO##
	call	MYHOOK

	ld	a,3		;Do a DOS1 style SETINT
	ld	ix,SET1INT##
	ld	hl,@TIME_IRQ##
	call	CALBNK##

	;ld	a,(FCALSAV##)	;TODO: Investigate why FCALSAV is all zeros
	;or	a		;at this point (should be all RETs)
	;jr	nz,FCALSAV_OK
	;ld	a,0C9h	;Code for RET
	;ld	(FCALSAV##),a
;FCALSAV_OK:
	
	ld	a,3
	ld	(MAIN_BANK##),a

	ld	hl,58A8h		;Start of initialization of DOS1
	push	hl			; CLEAN+11h (just after RET P) of
	ld	a,3			; INIT.Z80, not INIT.MAC (this code).
	jp	CHGBNK##
;
;
;===== start add DOS2.50 (build type)
else
if STURBO
;
CHECK_1KEY:
    ld a,(BOOTKEYS##) ;If "1" key is pressed at THIS (oops) moment, no change mode.
	ret	nz
	ld	a,(VERSION)
	cp	3		;MSXturboR?
	ret	c		;no
	ld	a,82h		; otherwise switch to "super turbo" mode
	jp	CHGCPU		; (lighting indicator also) and return.
endif
;
;===== end add DOS2.50
endif
	subttl	MSX-DOS1 compatible ROM entries (part 3)

	ALIGN	535Dh
BUFOUT:	exx
	push	bc		;Get error code in B' if it ever servives.
	exx
	call	CRLF
	ld	a,__ASTS##	;Get the message string by a BDOS
	ld	de,($SECBUF##)	; call and print it out preceeded by
	call	ROM_MSG##	; "*** " and followed by a newline.
	call	OUT_MSG
	pop	bc
	ld	de,($SECBUF##)
	ld	c,_EXPLAIN##
	call	BDOS##
OUT_MSG:
	ld	a,(de)
	or	a
	ret	z
	push	de
	ld	e,a
	call	CONOUT
	pop	de
	inc	de
	jr	out_msg
;

	ALIGN	53A7h
CONOUT:	CALLDOS	02h	;Console output
;
_PRTBUF:
	ld	hl,1Ah+0C9h*256	;"LD A,(DE)" then "RET"
	push	hl
	call	RD_MEM
	pop	hl
	cp	"$"
	ret	z
	push	de
	ld	e,a
	call	CONOUT
	pop	de
	inc	de
	jr	_PRTBUF
;
RD_MEM:
	ld	hl,$DOSON##
	push	hl
	ld	hl,4
	add	hl,sp
	push	hl
	jp	$DOSOFF##


;DIV16 and PANIC routines mnoved here since code overwrapped

;
; DIV16     [BC]=[BC]/[DE], remainder in HL.  Preserves DE, IX, IY.
;
	public	DIV16
DIV16:
	ld	hl,0
;;	call	H.DIV32
	ld	a,17
div_loop:
	rl	c
	rl	b
	dec	a
	ret	z
;
	adc	hl,hl
	jr	nc,fit_16bit
	or	a		;Remainder exceeds 16 bit
	sbc	hl,de		;This always generates carry
	jr	div_loop
fit_16bit:
	sbc	hl,de
	jr	nc,no_rest
	add	hl,de		;Restore since divisor didn't fit
no_rest:
	ccf			;Prepare quotient bit
	jr	div_loop


PANIC_TOOMD:
	ld	a,__TOOMD##
	jr	PANIC
PANIC_NOEMP:
	ld	a,__NOEMP##
	jr	PANIC
PANIC_BADDI:
	ld	a,__BADDI##
	jr	PANIC
PANIC_INIT:
	cp	1
	jr	nz,PANIC_INIT2
	ld	(MFLAGS##),a
	ret
PANIC_INIT2:
	ld	h,a
	ld	a,__INITE##
	jr	PANIC
PANIC_HIMEM:
	ld	a,__BHIM##

PANIC:	push	hl
	push	af
	ld	a,CLS
	call	$OUT
	pop	af
	push	af
	ld	de,BUF		;Can't be a PRT_ROM_MSG
	call	ROM_MSG##	; because buffer may not yet be allocated.
	call	MSG_DE
	pop	af
	cp	__INITE##
	jr	nz,PANIC2
	pop	af
	add	a,"0"
	call	$OUT
PANIC2:
	di
	halt

	ALIGN	543Ch
CONST:	CALLDOS	0Bh	;Console status
;
	ALIGN	5445h
CONIN:	CALLDOS	01h	;Console input
;
	ALIGN	544Eh
INNOE:	CALLDOS	08h	;Console input, no echo
;
	ALIGN	5454h
DIRIO:	CALLDOS	06h	;Direct console I/O
;
	ALIGN	5462h
RAWINP:	ld	c,07h	;Direct console input, no echo
	ld	de,$-$	;skip next 2 bytes
	org	$-2
;
	ALIGN	5465h
LSTOUT:	CALLDOS	05h	;List output
;
	ALIGN	546Eh
AUXIN:	CALLDOS	03h	;Auxilliary input
;
	ALIGN	5474h
AUXOUT:	CALLDOS	04h	;Auxilliary output
;
	ALIGN	553Ch
GDATE:	CALLDOS	2Ah	;Get date
;
	ALIGN	5552h
SDATE:	CALLDOS	2Bh	;Set date
;
	ALIGN	55DBh
GTIME:	CALLDOS	2Ch	;Get time
;
	ALIGN	55E6h
STIME:	CALLDOS	2Dh	;Set time
;

	ALIGN	55FFh
VERIFY:	CALLDOS	2Eh	;Set/reset verify flag
;

;--- Check boot sector type
;    Input:  sector data at BOOTAD
;    Output: A = sector type:
;                0 = DOS 1
;                1 = DOS 2.20 or 2.3x
;                2 = Standard

BSEC_TYPE:
	;1) Check for "VOL_ID", if found, return type 1

	ld	hl,BOOTAD + UPB_VOLID##
	ld	de,VID_STR
	ld	b,6
	call	CP_FLSTR
	ld	a,1
	ret	z

	;2) Check for sector count >65535, if so, return type 2

	ld	hl,BOOTAD + UPB_SEC##
	ld	a,(hl)
	inc	hl
	or	(hl)
	ld	a,2
	ret	z

	;3) Check for EBS, if found, return type 2

	ld	a,(BOOTAD + UPB_EBS##)
	and	028h
	cp	028h
	jr	nz,NOEBS

	ld	hl,BOOTAD + UPB_FILESYS##
	ld	de,FAT_STR
	ld	b,4
	call	CP_FLSTR
	jr	nz,NOEBS

	ld	a,2
	ret
NOEBS:

	;4) If all failed, assume a DOS 1 disk

	xor	a
	ret

FAT_STR:	db	"FAT1"
VID_STR:DEFB	"VOL_ID"


;--- Compare strings of fixed length
;    Input: HL, DE=strings, B=length
;    Output: Z set if same strings

CP_FLSTR:
	ld	a,(de)
	cp	(hl)
	ret	nz
	inc	hl
	inc	de
	djnz	CP_FLSTR
	ret


;--- Get SLTWRK entry address for a given slot
;    Input:  A  = Slot number, if 0, current slot in page 1
;    Output: IX = Work area address, A = Slot number
;    Modifies: F

GWRK::
	or	a
	jr	nz,GWORK2
	call	GSLT1
GWORK2:
	push	af
	push	bc
	ld	b,a
	rrca
	rrca
	rrca
	and	01100000b
	ld	c,a	;C = Slot * 32
	ld	a,b
	rlca
	and	00011000b	;A = Subslot * 8
	or	c
	ld	c,a
	ld	b,0
	ld	ix,SLTWRK##
	add	ix,bc
	pop	bc
	pop	af
	ret


;--- Clear the SLTATR area corresponding to pages 0, 2 and 3
;    for this slot.
;    This is necessary because when using ROM mappers that mirror
;    information in various pages, MSX BIOS incorrectly interprets
;    that there is BASIC expansion statement management code
;    in these pages, but pointing to code in page 1.
;    This causes a crash when invoking a non existing CALL
;    command from BASIC.

CLEAR_STAT_P2:
	call	GSLT1
	ld	b,a
	and	11b
	rla
	rla
	rla
	rla		;Main slot * 16
	bit	7,b
	jr	z,clstat_noexp
	ld	c,a
	ld	a,b
	and	1100b	;Secondary slot * 4
	add	a,c
clstat_noexp:
	ld	c,a
	ld	b,0
	ld	hl,SLTATR##
	add	hl,bc	;Base address for this slot

	ld	(hl),0	;Clear page 0 bits
	inc	hl
	inc	hl
	ld	(hl),0	;Clear page 2 bits
	inc	hl
	ld	(hl),0	;Clear page 3 bits
	
	ld	hl,H.RUNC
	ret


;--- Check if a disk driver is actually present in bank 5,
;    if not, show an error message and halt the system.

CHK_DRIVER:
	ld	hl,CHK_CODE
	ld	de,BUF
	ld	bc,CHK_CODE_SIZE
	ldir

	ld	hl,CHGBNK##
	ld	de,BUF+CHBANK_CODE-CHK_CODE_START
	ld	bc,32
	ldir

	call	BUF

	ld	hl,BUF	;Leave the buffer as we found it
	ld	de,BUF+1
	ld	(hl),0
	ld	bc,CHK_CODE_SIZE+32-1
	ldir

	ret

	;* This code is copied to RAM and then executed
	;  (since we need to switch to driver bank)

CHK_CODE:
	.phase BUF
CHK_CODE_START:
	ld	a,DV_BANK##
	call	CHBANK_CODE	;We need to use the CHGBNK code copied
				;to RAM because we don't know if the bank
				;has a valid driver (and hence the
				;CHGBNK code itself)
	
	;Search the disk driver signature

	ld	hl,DRV_STRING
	ld	de,4100h
chkd_loop:
	ld	a,(de)
	cpi
	jr	nz,chkd_panic
	or	a
	jr	z,chkd_ok
	inc	de
	jr	chkd_loop

	;Found, restore bank 0 and return

chkd_ok:
	xor	a
	jp	CHGBNK##	;Now we use CHGBNK directly because
				;we know that the bank has a valid driver

	;Not found, show error message and halt the system

chkd_panic:
	ld	hl,chkd_pstring
chkd_panicloop:
	ld	a,(hl)
	or	a
	jr	z,chkd_panicend
	call	CHPUT
	inc	hl
	jr	chkd_panicloop

chkd_panicend:
	di
	halt

chkd_pstring:
	db	12,"Disk driver not found.",13,10
	db	"System halted.",0

DRV_STRING:
	db	"NEXTOR_DRIVER",0
CHBANK_CODE:	;The code for CHGBNK will be copied here

	.dephase

CHK_CODE_SIZE	equ $-CHK_CODE


;
;-----------------------------------------------------------------------------
;
;	Media formatter
;
;	HOKFMT:   FORMAT hook and 'CALL FORMAT' comes here.
;	$FORMAT:  CLI FORMAT command comes here.
;
HOKFMT::
	or	a
$FORMAT::
	ei
	jr	c,GOT_AVAILABLE
;
;	get available memory if called from BASIC
;
	ld	hl,-256		;calculate end of work area
	add	hl,sp
	ld	de,(STREND)	;get start of work area
	xor	a
	sbc	hl,de		;calculate work area length
	ld	c,l
	ld	b,h
	ex	de,hl		;set start of work area in [HL]
	jr	nc,GOT_AVAILABLE;free area is OK
	ld	c,a		;say no work area is available
	ld	b,a

GOT_AVAILABLE:
	push	hl		;save start of available memory
	push	bc		;save length of available memory
;
	ld	l,0
	ld	bc,8*256+_FORMAT##
FMT_CHK_DRIVE:
	add	hl,hl
	push	hl
	push	bc
	xor	a		;See if format is supported by
	call	BDOS##		; drive [B].
	pop	bc
	pop	hl
	jr	nz,FMT_NO_DRIVE	;Any error means drive does not exist
				; or does not support format.
	inc	hl		;Add to the selection list.
FMT_NO_DRIVE:
	djnz	FMT_CHK_DRIVE
;
	ld	a,l		;If nothing remain, no way to proceed.
	or	a		;
	jp	z,FMTABO2	;
;
	dec	a
	and	l
	ld	a,l		;If only one drive,
	jr	z,FMT_1DRIVE	; no need to ask for drive name
;
	push	hl		;Save drive list.
	ld	a,__FMT1##
	call	PRT_ROM_MSG	;"Drive name? (".
	pop	hl
	push	hl
	ld	a,"A"-1
FMT_ASK_LOOP:
	inc	a		;Try next drive
	srl	l
	jr	nc,FMT_SKIPDRV
	call	$OUT		;Print drive name.
	push	af
	ld	a,","
	call	nz,$OUT		;Print separator if something remain.
	pop	af
FMT_SKIPDRV:
	jr	nz,FMT_ASK_LOOP
;
	ld	a,__FMT2##
	call	PRT_ROM_MSG	;") " after drive name list.
	pop	hl		;Restore drive list

FMT_ASKAGAIN:
	call	GET_CHAR
	jp	z,FMTABO2	;abort
;
	and	not 20h		;Force to upper case
	ld	c,a
	sub	"A"
	cp	8
	jr	nc,FMT_ASKAGAIN	;Invalid drive name.
;
	ld	b,a
	inc	b
	xor	a
	scf
FMT_GETMASK:
	rla
	djnz	FMT_GETMASK
	and	l
	jr	z,FMT_ASKAGAIN	;Drive does not exist
				; or does not support format.
	push	af
	ld	a,c
	call	$OUT		;Echo to the console.
	call	PRT_CRLF
	pop	af

FMT_1DRIVE:			;Always comes here with B=0.
FMT_GETDRIVE:
	inc	b		;Convert bit mask back to drive number.
	rrca			;
	jr	nc,FMT_GETDRIVE
;
;	Here with physical drive number in [B] (1 based)
;
	ld	c,_FORMAT##
	push	bc		;Save drive number and _FORMAT
	xor	a		;Return choice string
	call	BDOS##		; B = slot
				; HL = pointer to choice
	ld	a,l		;Is there any choice?
	or	h
	jr	z,NO_CHOICE	;No choice
;
	ld	a,b		;set target slot address
CHOILP:
	push	af
	call	RDSLT		;get choice string
	or	a		;end of string?
	jr	z,CHOIED	;yes
	call	$OUT
	pop	af
	inc	hl
	jr	CHOILP
;
CHOIED:
	pop	af		;discard stack
	ld	a,"?"
	call	$OUT
	ld	a," "
	call	$OUT
;
CHOICE_ASKAGAIN:
	call	GET_CHAR
	jr	z,FMTABO3	;abort
;
	sub	"1"
	cp	9
	jr	nc,CHOICE_ASKAGAIN
;
	add	A,"1"
	call	$OUT		;echo choice
	call	PRT_CRLF
	sub	"1"
;
NO_CHOICE:
;
;   Here with choice number in [A] (one less, i.e. 0~8)
;
	inc	a		;Make choice number 1 based
	push	af		; and save it.
	ld	a,__STRIKE##
	call	PRT_ROM_MSG	;"Strike a key when ready "
;
	call	GET_CHAR
	jr	z,FMTABO4	;abort
;
	call	PRT_CRLF
	pop	af		;restore choice number
	pop	bc		;restore drive number and _FORMAT
	pop	de		;restore length of available memory
	pop	hl		;restore start of available memory
	call	BDOS##
	jr	z,FMT_COMPLETE	;no errors
;
	ld	b,a		;set error code
	ld	de,($SECBUF##)	;set error messsage buffer
	ld	c,_EXPLAIN##
	call	BDOS##
	jp	MSG_DE
;
FMT_COMPLETE:
	ld	a,__FORMAT##	;"Format complete"
	jr	FMTEND
;
FMTABO4:
	pop	af
FMTABO3:
	pop	af
FMTABO2:
	pop	af
	pop	af
	call	PRT_CRLF
	ld	a,__ABORT##	;"Aborted"
FMTEND:
	call	PRT_ROM_MSG
	jp	PRT_CRLF
;
;=======================================================================
;
GO_DOS2:
	xor	a
	ld	(CPMCALL##),a
	jp	DOS1_GO##
;

;Return Z if direct jump to BASIC is required
;(so don't run NEXTOR.SYS, AUTOEXEC.BAS or the boot sector code)

TO_BASIC_REQUIRED::
    ld a,(NOTFIRST##)
    inc a
	dec a
    ret nz

    ld a,(BOOTKEYS##)
    and 00001000b
    xor 00001000b
	ret

GET_DISKID_HL:
	ld	hl,DISKID
	ld	a,(hl)
	inc	a
	ret	nz
	ld	hl,PROCNM+8
	ret

;This routine copies BC bytes from HL to DE.
;If DE=HL does nothing, if DE<HL uses LDIR, if DE>HL uses LDDR.
;Corrupts AF.

MEMCPY:
	ld	a,d
	cp	h
	jr	c,DO_LDIR
	jr	nz,DO_LDDR

	ld	a,e
	cp	l
	jr	c,DO_LDIR
	ret	z

DO_LDDR:
	push	bc
	add	hl,bc
	ex	de,hl
	add	hl,bc
	ex	de,hl
	pop	bc
	lddr
	ret

DO_LDIR:
	ldir
	ret

    ;Call DRV_INIT in my slot.
    ;Input: A, B = Input for the routine.

CALL_DV_INIT:
    push af
    push bc
    ld a,(BOOTKEYS##)
    and 00100000b
    pop bc
    ld c,a
    pop af
    ld	ix,DV_INIT##	;Initialize environment and hardware
	ex	af,af'
	ld	a,DV_BANK##
	call	CALBNK##
    ret

FOURZEROS:	db	0,0,0,0

	end

