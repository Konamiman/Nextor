	.z80
	title	MSX-DOS 2 KERNEL   Copyright (1986)  IS Systems Ltd.
	subttl	CP/M Disc Functions
;*****************************************************************************
;
	INCLUDE	MACROS.INC
	INCLUDE	CONST.INC
	;RAMMOD		;Removed since now this code is ran from bank 4 of ROM
;
;-----------------------------------------------------------------------------
;
;       This file contains the CP/M compatible disc functions, ie they work
; externally using FCBs rather than FIBs and FABs.  Internally, however, it
; is necessary for them to use FIBs and FABs and then call the main MSX-DOS
; routines.   They  therefore extract form the FCBs passed to them, all the
; information that is necessary to set up skeleton FIBs and  FABs.   Having
; done any operation, any results are placed back in the FCBs.
;       The FCBs are not exactly the same as CP/Ms but they are compatible.
; The internal bytes in them, and the block bytes, are  used to  store  any
; internal information needed about cluster numbers, and various flag bits.
;
;
; EQUs for the new flag bits in CP/M FCBs.
;
CP_EOF	EQU	4
CP_DEV	EQU	5
CP_RO	EQU	6
CP_MOD	EQU	7
;
;------------------------------------------------------------------------------
;
	PROC	F_FOPEN
;
;        This is the CP/M "open file" function.   It  does  its  own  internal
; search  for a file (using routine "S_F_F") and then does an "open file" call
; to MSX-DOS.  The user's CP/M FCB is then set up from the  opened  FAB.   The
; high  byte  of the extent field in the user's FCB is zeroed (along with byte
; S1) and the record count byte is set  up  appropriately  for  the  specified
; extent.
;
; Entry:        DE -> FCB.
;
		ld	iy,RAM_BASE##

		LD	(IY+@SE_FLAGS##),SEM_SR	;OPEN searches, doesn't CREATE.
		LD	A,ATM_HID		;Find hidden files as well.
		LD	C,1			;Do append if necessary.
OPEN_ENTRY:	CALL	M_F_F			;Locate the file and moan
		JR	NZ,RET_ERR		; if couldn't find it.
;
;       On returning, IX -> FIB.
;                     HL -> unit descriptor.
;                     DE -> directory entry.
;
		XOR	A			;Access flags.
		PUSH	DE			;Directory entry address.
		PCALL	OPEN_FAB		;The FIB will become a FAB.
;
		POP	DE			;Directory entry address.
		LD	HL,(FCB_ADR##)		;Reset the FCB with results.
		PUSH	HL
		LD	A,(APPEND_FLAG##)	;If this was an append, then
		OR	A			; set up drive in the FCB, so
		JR	Z,NOT_APPEND		; reads/writes will work.
		LD	A,(FIB_1##+FAB_DRV##)	;Drive in FAB.
		LD	(HL),A
NOT_APPEND:	CALL	SAVE_FNAME		;Copy the filename across.
		INC	HL			;HL returned pointing to low
		LD	A,(DE)			; byte of extent, whilst DE
		LD	(HL),A			; points to attr of dir entry.
		INC	HL			;Put attributes byte into s1,
						; for MSX-DOS compatibility.
		LD	(HL),0			;Zero high byte of extent.
		POP	IX			;-> FCB.
		CALL	SAVE_FAB		;Update FCB from the FAB.
		XOR	A			;As open, point to record zero.
		CALL	SET_EXT_REC		;Set up file pointer, simply in
		CALL	SET_REC_COUNT		; order to calculate extent no.

		LD	A,(FIB_1##+FAB_DRV##)	;Flush any dirty buffers for
		PCALL	FL_LOG			; this drive.  [HF]
;
RET_NO_ERR:	XOR	A			;Successful.
		LD	L,A
		LD	H,A
		RET				;Finally finished.
;
;
RET_ERR:	LD	HL,00FFh		;L=0FFh => error.
		RET				;With actual error in A.
;
;
;------------------------------------------------------------------------------
;
	PROC	F_FCLOSE
;
;        The CLOSE FILE function basically calls ENSURE_FAB which will  update
; the  disc  if necessary.  It also calls "FL_LOG" to make sure that any dirty
; buffers are flushed to disk.
;
;
		ld	iy,RAM_BASE##

		CALL	GET_FAB			;Setup FAB from CP/M FCB.

		JR	NZ,RET_ERR

		LD	DE,(FCB_ADR##)
		CALL	GET_FNAME		;Need filename field for close.
		PCALL	ENSURE_FAB		;Update directory entry if
		OR	A			; required.
		JR	NZ,RET_ERR
		LD	A,(IX+FAB_DRV##)	;Flush any dirty buffers for
		PCALL	FL_LOG			; this drive.
		JR	RET_NO_ERR
;
;
;------------------------------------------------------------------------------
;
;        Here are the SEARCH FOR FIRST and  SEARCH  FOR  NEXT  functions.   In
; principle they are  very simple.   Search for first just calls "S_F_F" which
; actually looks for a file.   Having found a file the FAB is then copied into
; "SRCH_FIB" ready for a search for next call, and the located directory entry
; copied to the user's DMA address.
;
;        SEARCH FOR NEXT simply copies the FIB at "FIB_1" back to the main FIB
; ("FIB_1") and then calls the routine "S_F_N".   When it has found a file
; it behaves exactly like search for first.
;
;        There  is  a  complication in that the extent number and record count
; fields in the located directory entry must be set up according to the extent
; number in the original user's FCB.  This  extent  number  is  remembered  in
; "SFN_EX"  and  used after a file has been found.  If the requested extent is
; beyond the end of the file then this file is ignored and  another  match  is
; searched for.
;
;
; Entry:        DE -> FCB.
;
	PROC	F_SFIRST
;
		ld	iy,RAM_BASE##

		LD	HL,CP_EXL
		ADD	HL,DE			;-> low extent byte.
		LD	A,(HL)			;Remember search extent for
		LD	(SFN_EX##),A		; future search for next calls.
;
		LD	(IY+@SE_FLAGS##),SEM_SR	;Search rather than create.

		LD	A,(DE)			;If MSB of drive number is set
		ADD	A,A			; search for directory + normal
		SBC	A,A			; files.  [HF]
		AND	ATM_DIR
		LD	C,0			;Don't follow append path.

		CALL	S_F_F			;Set up FIB, and find file.
		JR	NZ,RET_ERR		;Error if not found.
;
		JR	GOT_SEARCH
;
;        --------------------------------
;
;
	PROC	F_SNEXT

		ld	iy,RAM_BASE##
;
SNEXT2:		LD	DE,FIB_1##		;Get information about file
		LD	HL,SRCH_FIB##		; to search for.
		LD	BC,FIB_SZ##
		LD	A,(HL)			;Check to see if a previous
		CP	0FFh			; S_F_F has really been done
		LD	A,.NOFIL##		; by seeing if the FCB that
		JP	NZ,RET_ERR		; would have been stored is
		LDIR				; legal.
;
		CALL	S_F_N
		JP	NZ,RET_ERR
;
GOT_SEARCH:	PUSH	DE			;Address of directory entry.
		LD	HL,FIB_1##		;Copy search FIB into an
		LD	DE,SRCH_FIB##		; internal buffer search
		LD	BC,FIB_SZ##		; for next search for
		LDIR				; next.
		POP	DE			;Address of directory entry.
;
		LD	HL,TEMP_FCB##		;Create a temporary version
		LD	A,(FIB_1##+FIB_DRV##)	; as DTA will be in another
		LD	(HL),A			; page, so copy later.
		CALL	SAVE_FNAME		;Save filename entry there.
;
		LD	A,(SFN_EX##)		;Set extent byte in FCB.
		LD	(HL),A			;HL -> low byte of extent on
		INC	HL			; return from SAVE_FNAME.
;
		LD	A,(DE)			;Make s1 byte = attributes, for
		LD	(HL),A			; MSX-DOS compatibility.
		INC	HL
		INC	DE			;Increment directory pointer
		INC	DE			; as well, for LDIR later.
;
		LD	(HL),0			;Zero high byte of extent
		INC	HL			; in CPM_FCB.
		INC	DE
;
		EX	DE,HL
		LD	BC,33-(12+3)		;Copy rest of directory entry
		LDIR				; into the CP/M FCB.
;
		LD	IX,TEMP_FCB##		;-> FCB.
		XOR	A			;Set file pointer in FAB to the
		CALL	SET_EXT_REC		; start of extent, so we can
		CALL	SET_REC_COUNT		; set the record count in the
		JR	C,SNEXT2		; CP/M FCB and loop to search
						; again if extent doesn't exist
;
		LD	HL,TEMP_FCB##		;Copy the 33 byte unopened FCB
		LD	DE,(DTA_ADDR##)		; to the user's DMA address in
		LD	BC,33			; in the TPA.
		LD	A,RFM_RD		;Set read flag, clear paging
		PCALL	SEG_LDIR		; mode flag & do the copy.
;
		JP	RET_NO_ERR		;Return with no error code.
;
;------------------------------------------------------------------------------
;
	PROC	F_RDSEQ
;
;        The READ SEQUENTIAL function call is more complicated than you  might
; expect  because  of  the  file  buffering  which is done and because partial
; sectors have to be padded out with zeros.
;
;
		ld	iy,RAM_BASE##

		CALL	GET_FAB			;Set up FAB w/o filename.

		JR	NZ,RD_ERR

		LD	IX,(FCB_ADR##)
		CALL	SET_RAND_REC		;Set random record field of
						; CP/M FCB & file pointer of
						; FAB.
;
		LD	A,(FIB_1##+FAB_MODE##)	;If not a device, then we must
		BIT	MD_DEV,A		; check our internal buffer
		JR	Z,CHK_BUF		; first.
;
		LD	BC,128			;If it is a device, then we
		LD	DE,(DTA_ADDR##)		; must read directly, to avoid
		LD	IX,FIB_1##		; identification problems.
		XOR	A			;TPA Paging mode
		PCALL	RD_FAB
		JR	NZ,RD_ERR
		LD	IX,(FCB_ADR##)
		JR	DONE_RDSQ
;
CHK_BUF:	CALL	BUFFER_SECTOR		;If sector is in buffer then
		JR	Z,GOT_BUF_REC		; jump with its address.
;
		CALL	READ_BUFFER		;Read a buffer full and moan
		JR	NZ,RD_ERR		; if end of file.
;
		LD	HL,CPM_BUFF##		;Point to first sector in buff
GOT_BUF_REC:	CALL	LDIR_FROM_BUFF		;Copy 128 bytes from buffer
;
DONE_RDSQ:	CALL	INC_CURR_RECORD		;Adjust record/extent numbers
		CALL	SAVE_FAB		;Copy stuff back to CP/M FCB
		JP	RET_NO_ERR
;
RD_ERR:		LD	HL,0001			;Read error.
		RET				;With real error in A.
;
;
;
;---------------------------------------------------------------------------
;
	PROC	F_WRSEQ
;
;        The WRITE sequential function is fairly simple.  It calls "PURGE"  to
; invalidate  any data in the file buffer if it corresponds to this file.
;
;
		ld	iy,RAM_BASE##

		CALL	GET_FAB			;Set up FAB w/o filename.

		JR	NZ,RD_ERR

		LD	IX,(FCB_ADR##)
		CALL	SET_RAND_REC		;Set file pointer in FAB and
						; random rec. in CP/M FCB.
;
		CALL	PURGE_BUF		;Throw away buffered data
						; if it is for this file.
;
		LD	IX,FIB_1##		;-> FAB.
		LD	BC,128			;Write 128 bytes.
		LD	DE,(DTA_ADDR##)
		XOR	A			;Set up TPA paging mode.
		PCALL	WR_FAB
		JR	NZ,RD_ERR
;
		LD	IX,(FCB_ADR##)
		CALL	INC_CURR_RECORD		;Increment current record
		CALL	SAVE_FAB		;Save stuff back in CP/M FCB
;
		ld	a,(IX+CP_CR##)		;A := current record
		ld	hl,(FCB_ADR##)		;HL -> record count
		LD	BC,CP_RC##
		ADD	HL,BC
		CP	(HL)			;If current record is bigger
		JR	C,REC_COUNT_OK		; than record count then
		LD	(HL),A			; update record count byte.
REC_COUNT_OK:	JP	RET_NO_ERR		;Successful
;
;
;
;------------------------------------------------------------------------------
;
	PROC	F_FMAKE
;
;        This is the CREATE FILE function call.  If the extent number  in  the
; FCB  is  non-zero  then it first attempts to open that extent of an existing
; file by calling "F_FOPEN".  This is for compatibility with CP/M 1.4.  If the
; extent  is zero or if the file did not exist then a new file is created by a
; call to the find function with the search flags set accordingly.  This means
; that all this routine has to do in that case is to set up the  variable  and
; then jump to OPEN.
;
; Entry:     DE -> FCB.
;
		ld	iy,RAM_BASE##

		LD	HL,CP_EXL
		ADD	HL,DE			;-> low byte of extent.
		LD	A,(HL)			;If extent number is non-zero
		OR	A			; then try to open an existing
		JR	Z,NEW_CREATE		; file and return with no
		CALL	F_FOPEN			; error if it was opened OK.
		OR	A
		JP	Z,RET_NO_ERR
;
NEW_CREATE:	LD	(IY+@SE_FLAGS##),0	;Extent is zero or file does
		XOR	A			; not exist, so do create, by
		LD	C,A			; making the search flag zero
		JP	OPEN_ENTRY		; and then calling OPEN.
						;A = file attributes.
;
;
;------------------------------------------------------------------------------
;
	PROC	F_FDEL
;
;        The DELETE function is fairly straightforward.   It sets calls  S_F_F
; which  will  set  up  a FIB and find a matching file.   It will then try and
; delete this file.  Having done this, a call to S_F_N is  done  to  find  any
; more  matches,  and  they  are deleted also.   It does not attempt to delete
; read only, system, or hidden files.
;       If any file was deleted succesfully, then this routine will not return
; with an error.
;
; Entry:   DE -> FCB.
;
		ld	iy,RAM_BASE##

		ld	bc,00FFh		;Store result on stack.
		push	bc			;Save on stack throughout.
		ld	(iy+@BUF_UNIT##),c	;Flag no file deleted yet
						;Invalidate buffer just in case

		LD	(IY+@SE_FLAGS##),SEM_SR	;Search rather than create.
		XOR	A			;Don't delete hidden files.
		LD	C,A			;Don't follow append path.
		CALL	M_F_F			;Get FIB at FIB_1, find first,
		JR	START_DELETE		; and process it.
;
DELETE_LOOP_OK:	POP	BC			;Flag that a file has been
		LD	C,0			; deleted sucessfully.
		PUSH	BC
;
DELETE_LOOP:	CALL	M_F_N			;Find next file and stop
START_DELETE:	JR	NZ,DELETE_ERR		; if not found
		BIT	AT_RO,(IX+FIB_ATTR##)	;Don't delete read only files.
		JR	NZ,DELETE_LOOP
		LD	A,1			;Make disc dirty.
		PCALL	DEL_FIB			;Actually do the delete.  The
		OR	A			; registers will have come
		JR	Z,DELETE_LOOP_OK	; back from the search function
						; already set up for this.
		JR	DELETE_ERR
;
;
;--------------------------------------------------------------------------
;
	PROC	F_FREN
;
;        The RENAME function is very similar to the DELETE function above. The
; main  loop  is  identical except for not checking for read only files. Every
; time that a file is found for renaming, a call to REN_FIB is done which will
; actually do the renaming.  No error will be returned as long as at least one
; file has been successfully renamed.
;
; Entry:        DE -> FCB.
;
		ld	iy,RAM_BASE##

		LD	BC,00FFh		;Flag no file renamed yet
		PUSH	BC			;Stored on stack throughout.
		PUSH	DE			;FCB address.
;
		LD	IX,FIB_1##		;In order to squash the file
		LD	(IX+FIB_SA##),0		; name, need to set up search
		LD	HL,17			; attributes => not volume.
		ADD	HL,DE			;Point to renamed version.
		LD	DE,TEMP_FCB##		;Some spare memory where we
		EX	DE,HL			; store the ASCIIZ version of
		LD	A,(DE)			; the new filename.
		PCALL	SQ_NAME
;
		POP	DE			;-> FCB.
		XOR	A			;Don't find hidden files.
		LD	C,A			;Don't follow append path.
		CALL	M_F_F			;Try to find first file
;
		JR	START_RENAME		;Jump to do first rename
;
RENAME_LOOP_OK:	POP	BC			;Flag that a file has been
		LD	C,0			; renamed sucessfully.
		PUSH	BC
RENAME_LOOP:	CALL	M_F_N			;Find next file and stop
START_RENAME:	JR	NZ,RENAME_ERR		; if not found
;
		LD	BC,TEMP_FCB##		;-> ASCIIZ new filename.
		PCALL	REN_FIB			;Registers set up in search.
		OR	A
		JR	Z,RENAME_LOOP_OK
;
DELETE_ERR:
RENAME_ERR:	LD	B,A			;Save any error code.

		LD	A,(FIB_1##+FAB_DRV##)	;Flush any dirty buffers for
		PCALL	FL_LOG			; this drive.  [HF]

		POP	HL			;Return HL=FFh if no files
		LD	A,L			; deleted and HL=0 otherwise.
		OR	A			;If the error in A was the
		RET	Z			; expected file not found, then
		LD	A,B			; we must return A=0, otherwise
		RET				; return the real error code.
;
;
;------------------------------------------------------------------------------
;
;        This section does the random read, write and  write  with  zero  fill
; functions.
;
; Entry:        DE -> FCB.
;
	PROC	F_RDRND

		ld	iy,RAM_BASE##
;
		LD	A,RFM_RD		;Signify doing a read function.
		CALL	TRANSFER_RAND		;Set up FAB and do read.
		JR	NZ,RAND_ERR
;
		LD	A,C			;Number read.
		NEG
		AND	07Fh			;Test how much was read and
		LD	C,A			; if less than 128 bytes, pad

		LD	A,0			;PAD_SECTOR wants this.  [HF]

		CALL	NZ,PAD_SECTOR		; it out in the user's TPA.
		JR	RANDOM_RET
;
;
	PROC	F_WRRND
;
		XOR	A			;Signify function "write" or
		CODE	LXI HL			; "write with zero fill" and
						; call routine to set up FAB
						; and  do  the transfer from
	PROC	F_WRZER				; TPA.
;
		LD	A,RFM_ZF		;Signify zero write.
		CALL	TRANSFER_RAND
		JR	NZ,RAND_ERR		;Jump if error.
;
RANDOM_RET:	LD	IX,(FCB_ADR##)
		CALL	SET_REC_COUNT		;Set up record count byte.
		CALL	SAVE_FAB		;Save stuff back in CP/M FCB.
		JP	RET_NO_ERR
;
RAND_ERR:	LD	HL,0001			;If error from read or write
		RET				; then return HL=0001h and
						; error code in A.
;
;------------------------------------------------------------------------------
;
	PROC	F_FSIZE
;
;        This function searches for the first match with the filename  in  the
; FCB,  as in OPEN, and then rounds the size of the file up to the nearest 128
; bytes, and detremines the number of records.  The three byte  random  record
; field of the FCB is set to the number of records, so it is the number of the
; first record which doesn't exist.  The fourth  byte  of  the  random  record
; field is not altered.
;
; Entry:        DE -> FCB.
;
		ld	iy,RAM_BASE##

		LD	(IY+@SE_FLAGS),SEM_SR	;Search rather than create.
		LD	A,ATM_HID		;Find normal + hidden files.
		LD	C,0			;Don't follow append path.
		CALL	S_F_F			;Look for a matching file
		JP	NZ,RET_ERR		;Error if no match
;
		LD	C,(IX+FIB_SIZE##)	;Get file size into
		LD	B,(IX+FIB_SIZE##+1)	; DE:BC
		LD	E,(IX+FIB_SIZE##+2)
		LD	D,(IX+FIB_SIZE##+3)
;
		XOR	A			;Round file size up to nearest
		LD	H,A			; whole 128 byte sector to
		SUB	C			; ensure that any partial
		AND	127			; sector gets counted.
		LD	L,A
		ADD	HL,BC			;Correct low word of size
		JR	NC,NO_SIZE_CARRY
		INC	DE			;Carry into high byte of size
NO_SIZE_CARRY:
;
		ADD	HL,HL			;Multiply file size by two to
		LD	A,H			; give total number of 128 byte
		EX	DE,HL			; sectors in the top three
		ADC	HL,HL			; bytes (HL:A)
;
		LD	IX,(FCB_ADR##)
		LD	(IX+CP_RR##),a		;Record number of records in
		LD	(IX+CP_RR##+1),L	; the random record of FCB.
		LD	(IX+CP_RR##+2),H
;
		JP	RET_NO_ERR
;
;
;------------------------------------------------------------------------------
;
	PROC	F_SETRND
;
;        This routine simply sets the random record field in the user's FCB to
; the  value  calculated  from the current record and extent numbers.  This is
; done by calling SET_RAND_REC, which will also set up  the  file  pointer  in
; FIB_1, although this will never actually be set up as a FIB or FAB.
;
; Entry:        DE -> FCB.
;
		ld	iy,RAM_BASE##

		PUSH	DE			;Put FCB address into IX.
		POP	IX
		CALL	SET_RAND_REC		;Set random record in CP/M FCB
						; (Also sets file pointer in
						;  the FAB.)
		JP	RET_NO_ERR
;
;
;------------------------------------------------------------------------------
;
GET_FAB:
;
;    This routine is called immediately on entry to some functions which  are
; passed an FCB pointer in register DE.  It is passed the address of the FCB,
; in register DE, and will create a FAB at FIB_1 from it.  It does not create
; the filename part, as this needs to call quite a complicated routine and is
; not needed by all functions.
;
; Entry:     DE -> User's FCB anywhere in the TPA
; Returns:   IX -> FIB_1
;            (FCB_ADR) -> The FCB.
; Corrupts:  AF,BC,DE,HL,IX
;


		EX	DE,HL
		LD	(FCB_ADR##),HL		;Remember user's FCB address.
;
		LD	IX,FIB_1##		;Where to create a FAB.
		LD	(IX+FAB_FLG##),0FFh
		LD	A,(HL)			;Drive in CP/M FCB.

		AND	0Fh			;Ignore user code.  [HF]

		LD	(IX+FAB_DRV##),A
		ld	bc,CP_S1##		;restore FAB_ATTR and FAB_ACC
		add	hl,bc
		ld	a,(hl)
		bit	AT_RES,a
		;assume B=0 (CP_S1 < 256)
		jr	z,NOT_MOD2
		ld	b,ACM_MOD
NOT_MOD2:	ld	(ix+FAB_ACC##),b
		ld	(ix+FAB_ATTR##),a
		and	ATM_DEV			;restore FAB_MODE
		jr	z,NOT_DEV2
		ld	a,MDM_DEV+MDM_CPM+MDM_ASC
NOT_DEV2:	ld	(ix+FAB_MODE##),a
		LD	DE,FIB_1##+FAB_SIZE##	;Copy size field.
		ld	bc,CP_SIZ##-CP_S1##
		ADD	HL,BC			;Point to the FCB size field.
		;assume B=0 (CP_SIZ-CP_S1 < 256)
		ld	c,4
		LDIR
		LD	DE,FIB_1##+FAB_ID##	;Now the volume id.
		;assume B=0 (set "ldir")
		ld	c,4
		LDIR
		LD	DE,FIB_1##+FAB_FDC##	;Now the cluster bytes.
		;assume B=0 (set "ldir")
		ld	c,8
		LDIR

		XOR	A
		BIT	MD_DEV,(IX+FAB_MODE##)	;If this seems to be device FCB
		RET	Z			; error if device handler
		LD	L,(IX+FAB_ID##)		; address does not match with
		LD	H,(IX+FAB_ID##+1)	; itself extracted from
		LD	E,(HL)			;  device descriptor address.
		INC	HL
		LD	D,(HL)
		LD	L,(IX+FAB_ID##+2)
		LD	H,(IX+FAB_ID##+3)
		SBC	HL,DE
		RET	Z
		LD	A,.IFCB##
;
		RET
;
;
;-----------------------------------------------------------------------------
;
GET_FNAME:
;
;       This routine is passed the pointer to the user's FCB, and will take
; the filename from it, and put it in the FIB/FAB at FIB_1, in ASCIIZ form.
;
; Entry:        DE -> FCB.
; Returns:      IX -> FIB_1.
; Corrupts:     AF,DE,HL,IX
;


		LD	IX,FIB_1##
		LD	HL,FIB_1##+FIB_NAME##	;Where to store ASCIIZ version
		INC	DE			;Point to filename field.
		LD	A,(DE)			;Need to pass first ch. in A.
		LD	(IX+FIB_SA##),ATM_HID	;Type of name.
		pcall	SQ_NAME			;Go and squash the name.
		RET
;
;
;-----------------------------------------------------------------------------
;
LDIR_FROM_BUFF:
;
;        This simple little routine does an LDIR operation of 128  bytes  from
; the file buffer to the user's DTA address in the TPA.
;
; Entry:    HL = Start address in buffer.
; Returns:  BC,DE,HL = Normal LDIR results
; Corrupts:  AF,BC,DE,HL
;
;


		LD	DE,(DTA_ADDR##)		;User's TPA address
		LD	BC,128			;Size of transfer
		LD	A,RFM_RD		;Set read flag, clear paging
		PCALL	SEG_LDIR		; mode flag & do the copy.
		RET
;
;
;------------------------------------------------------------------------------
;

; This routine does the same as S_F_F but returns an error
; if the file is mounted to a drive.

M_F_F:
	call	S_F_F
	ret	nz

	pcall	CHKMNT
	ret

S_F_F:
;
;        These   routines  provide  search  for  first  and  search  for  next
; functions. They are passed the address of the FCB provided by the user,  and
; the  first  thing  to  be done is to prepare a FIB which may be passed to an
; internal MSX-DOS subroutine.  The routine will return a pointer  to  a  unit
; descriptor,  and  a set up FIB fot the entry that has been found.  If a file
; was not found the information may not be correct.
;        (SE_FLAGS) should  be  set up before calling this routine to indicate
; whether FND_FIRST is supposed to do a search or a create.
;        If this routine is called with the correct flags set, then it will do
; an  append  if  the  search  fails.  This basically means that if the search
; fails, it will look for an environment string called "APPEND",  and  if  one
; exists,  as  a  drive/directory name, it will retry the search using the new
; path.
;
; Entry:     A  =  search attributes (ie hidden files or not ??).
;            C  =  1 => follow append path if error results.
;               =  0 => give up if error results from search.
;            DE -> User FCB.
; Returns:   A  =  0 and Z-flag set if file was found OK
;               =  FFh and Z-flag clear if no file was found
;            DE -> directory entry attributes (only if A=0).
;            HL -> unit descriptor.
;            IX -> FIB.
; Corrupts:  AF,BC,DE,HL,IX.
;
;

		ld	(iy+@APPEND_FLAG##),0	;Firstly reset the append
						; flag so that the drive
						; in the FCB will not be
						; changed.
		LD	B,A			;Save search attributes.
		PUSH	BC			;Save append flag.
		LD	(FCB_ADR##),DE		;Save address of the FCB.
		LD	IX,FIB_1##		;Address of an internal buffer
		LD	(IX+FIB_SA##),A		; suitable for an FIB.
		PUSH	AF
		PUSH	DE			;Save FCB address.
		INC	DE			;Point to expanded filename.
		LD	HL,SQN2_BUF##		;Where to put ASCIIZ string.
		LD	A,(DE)			;Routine wants 1st char in A.
		PCALL	SQ_NAME			;Convert to ASCIIZ format.
;
		POP	DE			;Address of FCB.
		POP	AF			;A = search attributes.
		LD	B,A
		LD	A,(DE)			;Drive.

		AND	0Fh			;Ignore user code.  [HF]

		LD	DE,SQN2_BUF##
APPEND_ENTRY:	LD	C,PCM_DI		;Access disc if needed.
		PCALL	PAR_PATH		;Set up more of FIB.
		JR	NZ,S_F_F_ERR		;Give up if error.
		OR	C			;Or if any rubbish on the end.
		LD	A,.IPATH##		;On returning,
		JR	NZ,S_F_F_ERR		; HL -> unit descriptor.
		PUSH	HL			;Unit descriptor.
		LD	HL,FNAME_BUF##		;Expanded filename.
		LD	DE,FIB_1##+FIB_PAT##	;Copy into FIB.
		LD	BC,8+3
		PUSH	DE
		LDIR
		POP	DE			;Need to point to it for search
		POP	HL			;-> unit descriptor.
		PCALL	FND_FIRST		;Actually find the file.
FOUND_FILE:	OR	A
		JR	NZ,S_F_F_ERR		;Give up if error found.
		PUSH	DE			;Address of directory entry.
		PUSH	HL			;Address of unit descriptor.
		PCALL	FILL_FIB		;Get some useful information
		PCALL	GT_DVARS		; into the FIB.
		EX	DE,HL
		LDIR
		POP	HL			;Address of unit descriptor.
		POP	DE			;Address of directory entry.
		POP	BC			;Append flag is still there !!
		XOR	A			;No error if we've got this
		RET				; far.
;
S_F_F_ERR:	POP	BC			;Append flag.
		BIT	0,C
		JR	NZ,TRY_APPEND
		LD	(iy+@APPEND_FLAG##),0	;Reset append flag as failed.
						;A temporary address.
		OR	A			;Signify error and return.
		RET
;
TRY_APPEND:	LD	(CPM_BUFF##+300),A	;Save error code.
		PUSH	BC			;Save search attributes.
		LD	HL,APPEND_STRING	;"APPEND",0
		LD	DE,CPM_BUFF##		;Where to store append path.
		ld	b,0FFh			;Maximum size allowed.
		ld	(iy+@BUF_UNIT##),b	;Invalidate any info there.
		LD	A,1			;=> copy to current paging.
		;The following was PCALL GET_ENV (now cpm.mac and env.mac are in bank 4)
		CALL	GET_ENV##		;Find string.

if 0	
		;This is to be used if cpm.mac executes from RAM but env.mac executes from ROM
		push	iy
		ld	ix,GET_ENV##
		ld	(BK4_ADD##),ix
		ld	ix,?CALL4##
		ld	iy,(MASTER_SLOT##-1)
		jp	CALSLT##
		pop	iy
endif

		OR	A
		POP	BC			;Restore search attributes.
		RET	NZ			;Give up if error.
		PUSH	BC
		LD	C,PCM_ER
		LD	DE,CPM_BUFF##		;Address of string.
		LD	IX,FIB_1##
		XOR	A			;Default drive if none there.
		PCALL	PAR_PATH
		POP	DE			;Search attributes.
		RET	NZ
		LD	A,B			;Parse flags.
		AND	PFM_A+PFM_DR		;If both clear => nothing to
		JR	Z,RESTORE_ERROR		; do.
		LD	(iy+@APPEND_FLAG##),0FFh
		PUSH	DE			;Search attributes.
		LD	HL,(STR_PTR##)		;-> terminating character.
		LD	A,B			;If string looks like a
		AND	PFM_F+PFM_E		; filename or extension then
		JR	Z,NO_BACK_SLASH		; add a "\" on the end to
		LD	(HL),'\'		; make it look like a
		INC	HL			; directory.
NO_BACK_SLASH:	LD	DE,SQN2_BUF##		;Now copy the ASCIIZ version
COPY_FILENAME:	LD	A,(DE)			; of the FCB filename onto
		LD	(HL),A			; the end of the string, to
		INC	HL			; form the correct path to try.
		INC	DE
		OR	A			;ASCIIZ terminated by a null.
		JR	NZ,COPY_FILENAME
		POP	BC			;Restore search attributes to B
		XOR	A			;Use default drive if necessary
		LD	C,0			;Now set up stack to look like
		PUSH	BC			; no append is wanted.
		LD	DE,CPM_BUFF##		;Address of new path.
		JP	APPEND_ENTRY
;
RESTORE_ERROR:	LD	A,(CPM_BUFF##+300)	;Restore the original error
		OR	A			; code and return NZ.
		RET
;
APPEND_STRING:	DB	'APPEND',0
;
;


; Special versipn of S_F_N that acts as if FND_NEXT had returned an error
; when the file is mounted. 

M_F_N:
		LD	IX,FIB_1##
		LD	(IY+@SE_FLAGS),SEM_SR	;Flag not doing create.
		PCALL	O_FIB			;Download directory variables
		RET	NZ			; ready to continue search.
		LD	DE,FIB_1##+FIB_PAT##	;Expanded version of filename.
		PCALL	FND_NEXT
		jr	nz,M_F_N2

		pcall	CHKMNT

M_F_N2:
		LD	C,0			;Make sure don't do funny
		PUSH	BC			; things with append.
		JP	FOUND_FILE

S_F_N:
;
;       This is the internal search for next subroutine.  It is passed a FIB
; stored at FIB_1##, and it's job is to find the next occurence.  It returns
; the same results as the search for first subroutine.
;
		LD	IX,FIB_1##
		LD	(IY+@SE_FLAGS),SEM_SR	;Flag not doing create.
		PCALL	O_FIB			;Download directory variables
		RET	NZ			; ready to continue search.
		LD	DE,FIB_1##+FIB_PAT##	;Expanded version of filename.
		PCALL	FND_NEXT
		LD	C,0			;Make sure don't do funny
		PUSH	BC			; things with append.
		JP	FOUND_FILE

;
;
;------------------------------------------------------------------------------
;
TRANSFER_RAND:
;
;       This routine is the heart of the read/write random  functions,  which
; all  call  it  to do the actual work.   Firstly it sets up the FAB from the
; user's FCB, and then purges the read buffer.   Having done this, it sets up
; the file pointer in the FAB, and does the relevant call to the main MSX-DOS
; code.
;
; Entry:        DE -> FCB.
;               A  =  Function code to pass to RDWR_FAB.
; Returns:      A  =  Error code.
;               BC =  Number of bytes read/written.
;               DE =  Updated transfer address (DTA + BC).
;               IX -> FAB.
;               (FCB_ADR) -> FCB.
; Corrupts:     AF, BC, DE, HL, AF'.
;
		EX	AF,AF'			;Save function code.
		CALL	GET_FAB			;Setup FAB from CP/M FCB.

		RET	NZ

		LD	IX,(FCB_ADR##)		;Need IX pointing to FCB, for
		LD	A,(IX+CP_RR##)		; routines called before the
		LD	C,(IX+CP_RR##+1)	; main MSX-DOS one.
		LD	B,(IX+CP_RR##+2)	;Set up the FAB file pointer
		PUSH	AF			; from random record number.
		PUSH	BC			;And save on stack for use in
		CALL	SET_RAND_PTR		; calculating extent number.
		CALL	PURGE_BUF		;Throw away bufferred data
						; if it is for this file.
;
		POP	HL			;Get random record number
		POP	AF			; into HL:A.
		add	a,a
		adc	hl,hl			;Calculate extent number by
		ld	(ix+CP_EXL##),l		; multiplying top 17 bits
						; by two (effectively divide
		ld	(ix+CP_EXH##),h		; by 128).
						;Record current extent.
		srl	a			;Record bottom 7 bits as the
		ld	(ix+CP_CR##),a		; current record number.
;
		XOR	A			;User paging mode -> A'.
		EX	AF,AF'			;Get function code back.
		LD	BC,128			;BC := amount to read/write.
		LD	IX,FIB_1##		;IX -> Opened FAB.
		LD	DE,(DTA_ADDR##)		;Read/write to here.
		PCALL	RDWR_FAB		;Do the operation.
;
		RET
;
;
;------------------------------------------------------------------------------
;
BUFFER_SECTOR:
;
;        This routine decides if a required logical sector is  in  the  buffer
; and  if so returns a pointer to it in HL with the Z-flag set.  If the sector
; is not in the buffer then it returns NZ.
;
; Entry:     IX -> FCB.
; Returns:   Z-flag - set (Z) => sector is in buffer,  HL -> sector.
;                   - clear (NZ) => sector not in buffer
; Corrupts:  AF,BC,DE,HL
;
;
		CALL	CHK_FILE_BUF		;Return NZ if buffer is not
		RET	NZ			; for this file.
;
		ld	bc,(BUF_REC##+0-1)	;Get buffer sector into DE:B
		LD	DE,(BUF_REC##+1)
		LD	A,(IX+CP_RR##)		;Get required logical sector
		LD	L,(IX+CP_RR##+1)	; into HL:A
		LD	H,(IX+CP_RR##+2)
;
		SUB	B
		SBC	HL,DE
		RET	NZ			;Return if sector is way out
		LD	B,A			; of buffer.
		LD	A,(BUF_COUNT##)
		SUB	1			;Return NZ if buffer is empty
		RET	C
		CP	B			;Test if sector in buffer and
		RET	C			; return if not.
;
		XOR	A
		SRL	B
		RRA				;Sector is in buffer so get
		LD	C,A			; a pointer to it.
		LD	HL,CPM_BUFF##
		ADD	HL,BC
XORET:		XOR	A
		RET
;
;
;------------------------------------------------------------------------------
;
PURGE_BUF:	CALL	CHK_FILE_BUF		;Test if buffer is for this
		RET	NZ			; file and return if not.
;
		ld	(iy+@BUF_UNIT##),0FFh	;If buffer is for this file
						; then kill it.
		RET
;
;
;------------------------------------------------------------------------------
;
CHK_FILE_BUF:
		ld	a,(BUF_UNIT##)		;Compare unit number in CP/M
		cp	(IX+CP_DRV##)		; FCB with the one for the
						; buffer and return NZ if
						; they are different.
		RET	NZ
;
		LD	L,(IX+CP_FPC##)		;Compare first physical
		LD	H,(IX+CP_FPC##+1)
		LD	DE,(BUF_FPC##)		; clusters and return Z or NZ
		SBC	HL,DE			; to show whether equal.
		RET
;
;
;------------------------------------------------------------------------------
;
READ_BUFFER:
;
;        Reads a buffer full of data from the file position specified  by  the
; file pointer of the FAB and the random record field of the CP/M  FCB  (which
; must be equivalent).  The read will always try to stop on a 512  byte sector
; boundary  for  efficiency  reasons.   If  an error occurs or nothing is read
; then this returns A=01 and NZ to indicate end of file.  If something is read
; then the amount is rounded up to the nearest whole  sector  and  "BUF_COUNT"
; set up appropriately.  The  first  sector  in  the  buffer (which is the one
; required)  is  stored at "BUF_REC" for later testing.   Also the unit number
; and  first  physical cluster  from the CP/M FCB are stored in "BUF_UNIT" and
; "BUF_FPC" for later testing.   Any partial sector is padded out  with  zeros
;  using the routine "PAD_SECTOR".
;
; Entry:     IX -> FCB.
; Returns:   A  =  00h if sucessful (anything was read OK)
;               =  01h if nothing was read (end of file)
; Corrupts:  AF,BC,DE,HL
;
;
		ld	(iy+@BUF_UNIT##),0FFh	;Invalidate the buffer in case
						; of any error.
;
		LD	A,(IX+CP_RR##)		;Number of 128 byte records to
		AND	03h			; read is the size of the
		LD	B,A			; buffer, reduced by any odd
		LD	A,SECT_BUFF##		; sectors at start.  This makes
		SUB	B			; sure read ends on 512 byte
						; boundary.
;
		LD	B,A
		XOR	A			;BC := size of read required
		SRL	B			;      in bytes.
		RR	A
		LD	C,A
;
		PUSH	IX			;Save address of FCB.
		LD	IX,FIB_1##		;Read the required amount
		LD	DE,CPM_BUFF##		; of data into the buffer.
		LD	A,0FFh			;Read into buffer, not TPA.
		PCALL	RD_FAB
		POP	IX			;-> FCB.
;
		JR	Z,BUF_READ_OK
		CP	.EOF##			;Jump to error if any error
		JR	NZ,NONE_READ		; except .EOF
BUF_READ_OK:	LD	A,B
		OR	C			;Error if no bytes at all
		JR	Z,NONE_READ		; were read
;
		LD	HL,127			;Calculate number of sectors
		ADD	HL,BC			; read, rounding up to the
		ADD	HL,HL			; nearest one above.
		LD	(iy+@BUF_COUNT##),h	;Record number of sectors read
;
		XOR	A
		LD	B,A
		SUB	C			;Look at amount read to see
		AND	07Fh			; if there was a partial
		LD	C,A			; sector.

		LD	A,0FFh			;Pad buffer, not TPA.

		CALL	NZ,PAD_SECTOR		;Pad out any partial sector
;
		PUSH	IX			;-> FCB.
		POP	HL
		LD	BC,CP_RR##
		ADD	HL,BC			;Save random record number
		LD	DE,BUF_REC##		; in "BUF_REC" for later
		;assume B=0 (CP_RR < 256)
		LD	C,3			; testing in "BUFFER_SECTOR".
		LDIR
;
		ld	l,(ix+CP_FPC##)		;Record unit number and first
		ld	h,(ix+CP_FPC##+1)	; checking for same file.
		ld	(BUF_FPC##),hl		; physical cluster number for
		LD	A,(IX+CP_DRV##)
		LD	(BUF_UNIT##),A
;
		XOR	A			;Return with zero error code
		RET
;
;
NONE_READ:	XOR	A			;Return A=01h and NZ to
		LD	B,A			; indicate end of file.
		INC	A
		RET
;
;
;
;------------------------------------------------------------------------------
;
;    This routine is used to pad out a partial record with zeros.  The  amount
; to  be  padded  (which  must  not  be zero) is passed in register BC and the
; address (as returned from read call) in register DE.
;
; Entry:        BC = Amount to pad.
;               DE = Where to pad from.
;                A = Paging mode,  RF_PAGE clear => user's DTA
;                                            set => current segments
;
PAD_SECTOR:	PUSH	AF			;Save paging mode
		PUSH	DE
		AND	RFM_PG
		PCALL	GET_SEGMENT		;Translate DTA address into
		SET	7,D			; segment and page-2 address
		CALL	PUT_P2##		;Page-in the required segment
;
PAD_SEC_LOOP:	XOR	A
		LD	(DE),A
		INC	DE			;Loop to pad out BC byte
		DEC	BC			; with zeros.
		LD	A,B
		OR	C
		JR	Z,PAD_SEC_RET
		BIT	6,D
		JR	Z,PAD_SEC_LOOP
;
		POP	AF			;If crossed segment boundary
		AND	0C0h			; re-calculate the transfer
		ADD	A,40h			; address on the next segment.
		LD	D,A
		LD	E,0
		POP	AF			;Restore paging mode
		JR	PAD_SECTOR
;
PAD_SEC_RET:	POP	AF			;Clear stack
		POP	AF			;
		LD	A,(DATA_SEG##)		;Restore kernel data segment
		JP	PUT_P2##		; and return.
;
;
;------------------------------------------------------------------------------
;
INC_CURR_RECORD:
;
;        This routine is called for sequential read and write to increment the
; current record number in the CP/M FCB.  If the  record  number  reaches  80h
; then  the  extent  number  is  also  incremented.   If  the extent has to be
; incremented then the record count  field  for  the  new  extent  is  set  up
; appropriately.
;
; Entry:     IX -> FCB.
; Returns:   None
; Corrupts:  AF,BC,DE,HL
;
;
		inc	(ix+CP_CR##)		;Increment current record and
		ret	p			; return if same extent
;
		ld	(ix+CP_CR##),0		;Record new record number
						; start next extent.
		inc	(ix+CP_EXL##)		;If record goes to 80h then
		jr	nz,no_carry_cur_ext	; start next extent.
		inc	(ix+CP_EXH##)
no_carry_cur_ext:
		 ;	;
		 ;	;
;       Drop through to set up record count byte
		 ;	;
		 ;	;
;------------------------------------------------------------------------------
;
SET_REC_COUNT:
;
;        This  routine  sets up the record count byte of the CPM_FCB according
; to the file pointer and file size bytes of the FAB.  The file pointer is
; rounded down to  the  nearest extent and then subtracted from the file size,
; which is first rounded up to the nearest 128 byte sector.  This  gives the
; file size from this extent on.  If this is 16k or more then the record count
; is set to 80h since the extent must be complete.  If it is less than 16k
; then it is rounded up to the nearest whole record and divided by 128 to give
; the record count byte.
;
; Entry:     IX -> FCB.
;            FAB   stored at FIB_1.
; Returns:   Carry flag - set (C) => extent was beyond end of file
;                         clear (NC) => extent was within file
; Corrupts:  AF,BC,DE,HL
;
;
		LD	HL,(FIB_1##+FAB_SIZE##)
		XOR	A			; Get rounded file size into
		LD	B,A			;   BCHL.
		SUB	L
		AND	127
		LD	C,A
		ADD	HL,BC
		LD	BC,(FIB_1##+FAB_SIZE##+2)
		JR	NC,SRC10
;
		INC	BC
SRC10:		LD	A,(FIB_1##+FAB_PTR##+1)
		AND	0C0H			; Subtract file pointer rounded
		LD	D,A			;   down to the nearest extent.
		XOR	A
		LD	E,A
		SBC	HL,DE
		PUSH	BC
		EX	(SP),HL
		LD	BC,(FIB_1##+FAB_PTR##+2)
		SBC	HL,BC
		POP	HL
		LD	B,A			;Record count is zero if
		JR	C,PAST_EOF_EXT		; extent is past EOF.
;
		LD	B,80h			;Anticipate whole extent
		JR	NZ,FULL_EXTENT		;If size left >= 16k then this
		LD	A,H			; is a full extent so jump
		AND	0C0h			; accordingly.
		JR	NZ,FULL_EXTENT
		ADD	HL,HL			;If size left < 16k the get
		LD	B,H			; number of 128 byte sectors
						; into register B.
;
;
PAST_EOF_EXT:
FULL_EXTENT:
		ld	(ix+CP_RC##),b		;Record the record count
						; for this extent.
		RET
;
;
;
;------------------------------------------------------------------------------
;
;        This routine sets the random record field of the CP/M  FCB  according
; to the current record and extent fields and then sets up the file pointer in
; the FAB according to this record number.  If  called  at  "SET_EXT_REC" then
; the current record must already be in register A.  If called at SET_RAND_PTR
; then the random record number must already be in BC:A.
;       It is alright to set up the random record part of  any  FCB  that  has
; been  passed  to  a  routine, since it will already have been copied to some
; internal memory, which is guarenteed to be long enough.
;
; Entry:        IX -> CP/M FCB.
;               FAB   stored at FIB_1.
; Corrupts:     AF, BC, HL
;
SET_RAND_REC:	LD	A,(IX+CP_CR##)
SET_EXT_REC:
		ld	b,(IX+CP_EXH##)		;Get current extent and record
		ld	c,(IX+CP_EXL##)		; number into HL and A.
;
		ADD	A,A			;Convert extent and record
		SRL	B			; into logical record by
		RR	C			; dividing EXTENT:(REC*2)
		RRA				; by two.
;
		LD	(IX+CP_RR##),A		;Store logical record number
		LD	(IX+CP_RR##+1),C	; random record field of FCB.
		LD	(IX+CP_RR##+2),B
;
SET_RAND_PTR:	LD	HL,FIB_1##+FAB_PTR##	; Zero low byte of file ptr.
		LD	(HL),0
;
		SRL	B			;Convert logical record to
		RR	C			; high 3 bytes of file
		RRA				; pointer by dividing by 2.
		RR	(HL)			;Shift last bit into low byte
		INC	HL			; of file pointer.
		LD	(HL),A
		INC	HL			;Store the next three bytes
		LD	(HL),C			; of the file pointer.
		INC	HL
		LD	(HL),B
;
		RET
;
;
;
;------------------------------------------------------------------------------
;
SAVE_FAB:
;
;        This  routine  copies  certain fields from FIB_1, which will contain a
; FAB,  back  to the CP/M FCB.   The fields copied are the file size, volume id
; and cluster numbers.  The current record and extent and the random record are
; not altered by this routine but must be set  up  appropriately if required by
; the function.
;       A number of flags are also copied from the FAB; these are stored in the
; FCB in the high four bits of cluster numbers, since cluster nos,  are only 12
; bits long.
;
; Entry:     IX -> FCB
;            FAB   stored at FIB_1.
; Returns:   None
; Corrupts:  AF,BC,DE,HL
;
;
		PUSH	IX			;FCB address.
		POP	HL
		LD	BC,CP_SIZ##
		ADD	HL,BC			;Address in FCB to store size.
		EX	DE,HL
		LD	HL,FIB_1##+FAB_SIZE##	;File size.
		;assume B=0 (CP_SIZ < 256)
		LD	C,4			;Size is 4 bytes long.
		LDIR
		LD	HL,FIB_1##+FAB_ID##	;Volume id in FAB.
		;assume B=0 (set "ldir")
		LD	C,4			;Again 4 bytes long.
		LDIR				;Follows after size in FCB.
		LD	HL,FIB_1##+FAB_FDC##	;Start of 8 data bytes to copy.
		;assume B=0 (set "ldir")
		LD	C,8
		LDIR				;Again follows on directly.
;
		ld	a,(FIB_1##+FAB_ACC##)	;CP_S1(file attribute) <- all FAB_ATTR bits and AC_MOD bit
		bit	AC_MOD,a
		ld	a,(FIB_1##+FAB_ATTR##)
		res	AT_RES,a
		jr	z,NOT_MOD
		set	AT_RES,a
NOT_MOD:	ld	(ix+CP_S1##),a
		RET
;
;------------------------------------------------------------------------------
;
SAVE_FNAME:
;
;       This routine is passed the address of a directory entry, and of an
; FCB.  It's job is to copy the filename out if the directory entry, including
; the 0E5h fiddle, into the filename field in the FCB.
;
; Entry:        DE -> directory entry.
;               HL -> FCB.
; Returns:      DE -> byte after filename field in directory entry.
;               HL -> byte after filename field in FCB.
; Corrupts:     AF, BC, DE, HL.
;
		INC	HL			;Where to put expanded filename
		LD	A,(DE)			;First character of filename in
		CP	5			; directory entry, for 0E5h
		JR	NZ,NO_FID1		; fiddle.
		LD	A,0E5h
NO_FID1:	LD	(HL),A			;Shift filename back to user's
		INC	HL			; FCB, in case of ambiguities.
		INC	DE
		LD	BC,8-1+3		;Do the rest by an LDIR.
		EX	DE,HL
		LDIR
		EX	DE,HL			;Put pointers back in correct
		RET				; registers.
;
;******************************************************************************
;
	PROC	F_RDBLK
;
;       Data  is  written  from  the DTA, to the position in the random record
; field.  The record size is determined by bytes 0Eh and 0Fh of the  FCB.   If
; the  record  size is <64 bytes, then all four bytes of the random record no.
; are used, otherwise only the first three are used.
;        After  writing  the  data, the random record field is adjusted to the
; next record number in the file. The current record and extent fields are not
; used  or  altered.   The  file  size  is  updated  if necessary.
;        In  the  read  function, if not all the records can be read, then the
; random record number will only be adjusted to the first record not read.
;
; Entry:        DE -> FCB.
;               HL =  Number of records to read/write.
;
		LD	A,RFM_RD		;Signify read function.
		JR	BLK_ENT
;
;
	PROC	F_WRBLK
;
		ld	iy,RAM_BASE##

		XOR	A			;Signify write function.
;
BLK_ENT:	EX	AF,AF'			;Save function code.
		LD	A,.OV64K##		;Set up a default error for
		LD	(TEMP_FCB##+1),A	; memory overflow errors.
		PUSH	HL			;Save record count
;
		CALL	GET_FAB			;Setup FAB from the FCB.

		JP	NZ,MSX_FAIL		;FCB seems wrong.

		LD	IX,(FCB_ADR##)		;For my routines.
		CALL	PURGE_BUF		;Throw away bufferred data if
						; it is for this file
;
;
;     +++++++  Calculate file pointer for FAB  ++++++
;
;
		LD	C,(IX+CP_RS##)		;BC := Record size.
		LD	B,(IX+CP_RS##+1)
		LD	HL,63
		XOR	A			;Test whether record size
		SBC	HL,BC			; is 64 bytes or greater.
;
		LD	E,(IX+CP_RR##+2)	;Get top word of random record
		LD	D,(IX+CP_RR##+3)	; number into DE and zero top
		JR	NC,FOUR_BYTE_REC	; byte if record size is 64
		LD	D,A			; bytes or greater.
FOUR_BYTE_REC:	CALL	MULTIPLY		;Multiply top word of record
		LD	A,H			; number by record size and
		OR	L			; moan if overflows 16 bits.
		JP	NZ,MSX_FAIL_1
		PUSH	DE			;Save partial result.
;
		LD	E,(IX+CP_RR##)		;Multiply low word of record
		LD	D,(IX+CP_RR##+1)	; number by record size and
		CALL	MULTIPLY		; add the partial result
		POP	BC			; from above to top word.
		ADD	HL,BC
		JP	C,MSX_FAIL_1		;Moan if overflows 32 bits.
;
		LD	(FIB_1##+FAB_PTR##),DE	;Save final file ptr in FAB.
		LD	(FIB_1##+FAB_PTR##+2),HL
;
;
;     +++++++  Calculate transfer size & call MSX-DOS 2 ++++++
;
;
		POP	DE			;Multiply record size by number
		PUSH	DE			; of records to transfer to
		LD	C,(IX+CP_RS##)		; get required transfer size
		LD	B,(IX+CP_RS##+1)
		CALL	MULTIPLY
		LD	A,H			;Complain if the transfer size
		OR	L			; is greater than 64k.
MSX_FAIL_1_NZ:	JP	NZ,MSX_FAIL_1
;
		LD	C,E			;BC := transfer size
		LD	B,D
		PUSH	BC			;Save whole transfer size
		EX	AF,AF'			;A := function code
		PUSH	AF			;Save as read/write flag
		LD	IX,FIB_1##
		LD	DE,(DTA_ADDR##)
;
		BIT	RF_READ,A		;If it is a write block
		JR	NZ,NOT_ZERO_WRITE	; function and if byte count
		LD	A,B			; is zero then set the RF_SIZE
		OR	C			; flag to force the file size
		LD	A,0			; to be changed.
		JR	NZ,NOT_ZERO_WRITE
		SET	RF_SIZE,A
NOT_ZERO_WRITE:	PCALL	RDWR_FAB		;Transfer the data.
		LD	(TEMP_FCB##+1),A	;Save error code.
		LD	IX,(FCB_ADR##)		;My routines from now on !!
;
;
;     +++++++  Work out record count & zero fill partial record  ++++++
;
;
		POP	AF			;Get read/write flag back
		EX	AF,AF'			; into A'
		XOR	A
		POP	HL			;Test whether whole transfer
		SBC	HL,BC			; was done and if so then skip
		JR	Z,MSX_WHOLE		; calculation, with A=0.

		LD	(TEMP_FCB##+2),DE	;-> Next free DTA.
		LD	E,(IX+CP_RS##)		;Divide amount transferred (BC)
		LD	D,(IX+CP_RS##+1)	; by record size (DE).
		CALL	DIVIDE
		LD	A,H
		OR	L
		PUSH	BC			;If remainder is zero then no
		JR	Z,MSX_NO_PARTIAL	; partial record so skip.
		POP	BC
		INC	BC			;Bump record count to include
		PUSH	BC			; the partial record;
		EX	DE,HL
		SBC	HL,DE			;Calculate amount left in the
		LD	B,H			; partial record and put it
		LD	C,L			; into BC ready for zero fill.
		LD	DE,(TEMP_FCB##+2)	;Address to pad from.
		EX	AF,AF'
		BIT	RF_READ,A		;Zero fill the partial record
		CALL	NZ,PAD_SECTOR		; if it was a read function.
;
MSX_NO_PARTIAL:	POP	BC			;If requested records are
		POP	HL			; transferred it is treated as
		PUSH	BC			; whole transfer even if the
		XOR	A			; last record is partial.
		SBC	HL,BC			; (MS-DOS returns 3 in this
		JR	Z,MSX_WHOLE		; case.)
		INC	A			;Set A=1 to indicate error
MSX_WHOLE:
;
;
;     +++++++  Update user's FCB and return  ++++++
;
;
		EX	AF,AF'			;Save return code in A'
		CALL	SAVE_FAB		;Update CP/M FCB from FAB.
;
		POP	DE			;DE := records transferred
		LD	L,(IX+CP_RR##)
		LD	H,(IX+CP_RR##+1)
		ADD	HL,DE			;Add this to random record
		LD	(IX+CP_RR##),L		; number in CP/M FCB.
		LD	(IX+CP_RR##+1),H
		JR	NC,NO_RR_CARRY
		inc	(IX+CP_RR##+2)		;Increment high word if any
		jr	nz,NO_RR_CARRY		; overflow from low word.
		inc	(IX+CP_RR##+3)
NO_RR_CARRY:
		EX	AF,AF'			;A := 0/1 return code
		JR	MSX_EXIT_OK		;DE := records transferred
;
MSX_FAIL:	LD	(TEMP_FCB##+1),A
MSX_FAIL_1:	POP	HL			;Error in MSX function so
		XOR	A			; clean stack and set records
		LD	D,A			; transferred (HL) to zero.
		LD	E,A
		INC	A			;A=1 (error return)
;
MSX_EXIT_OK:	LD	L,A			;Return A in HL for Bruce.
		LD	H,0
		OR	A			;If A=1 then we need to put
		RET	Z			; the error number in A.
		LD	A,(TEMP_FCB##+1)
		RET
;
;
;----------------------------------------------------------------------------
;
DIVIDE:
;
; Entry:     BC = Dividend  (unsigned)
;            DE = Divisor   (unsigned, must be non-zero)
; Returns:   BC = Quotient
;            HL = Remainder
; Corrupts:  AF,BC,HL
;
;
		xor	a			;Ensure carry clear
		ld	h,a			;Start remainder at zero
		ld	l,a
		ld	a,16			;Loop count
;
divide_loop_1:	ccf				;Shift next bit into result
divide_loop_2:	rl	c			; and also shift next bit
		rl	b			; of dividend out.
		dec	a
		ret	m			;Return when divide finished
;
		adc	hl,hl			;Double previous remainder
		sbc	hl,de			;If remainder + next bit of
		jr	nc,divide_loop_1	; dividend is > divisor then
		add	hl,de			; jump to shift a "one" in
		or	a			; otherwise jump to shift
		jr	divide_loop_2		; a "zero" in.
;
;
;------------------------------------------------------------------------------
;
MULTIPLY:
;
; Entry:        DE = Multiplicand
;               BC = Multiplier (usually block size, preserved)
; Returns:   HL:DE = Result
; Corrupts:  AF,DE,HL
;
;
		push	bc			;Must preserve BC
		ld	a,b			;Get multiplier into A:C
		ld	hl,0			;Initialise result
		ld	b,16			;Loop conut
;
multiply_loop:	add	hl,hl			;Multiply partial result by
		rl	c			; two and shift out next
		rla				; bit of multiplier
		jr	nc,mult_no_add		;Skip if multiplier bit is zero
;
		add	hl,de			;If multiplier bit is set then
		jr	nc,mult_no_add		; add the multiplicand onto
		inc	c			; partial result, with any
		jr	nz,mult_no_add		; necessary carry to 32 bits.
		inc	a
;
mult_no_add:	djnz	multiply_loop		;Loop 'til done 16 bits
;
		ex	de,hl			;DE := low word of result
		ld	l,c
		ld	h,a			;HL := high word of result
		pop	bc
		ret
;
;
;------------------------------------------------------------------------------
;
	finish	<CPM>
	end
;
