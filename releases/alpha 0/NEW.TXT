MSX-DOS 2.50 alpha 1 new features


This document describes the changes and new features introduced in MSX-DOS 2.50 alpha 1, relative to MSX-DOS 2.20 and MSX-DOS 2.31. The changes in existing function calls, the new function calls, and the new error codes, are explained in a separate document.

NOTE: This information is provisional. MSX-DOS 2.50 is still under development.


    1. STROUT function: correction of the ESC-Y escape sequence bug

The STROUT function prints a string finished with a "$" character. There is a escape sequence that allows positioning cursor at any location in the screen, the sequence is: ESC (27) "Y" (89) x+32 y+32, where (x,y) is the desired character position.

The bug appears when this escape sequence is used and either the x or the y coordinate are 4. In this case, the third or fourth byte of the sequence becomes 36, which is the ASCII code of "$"; then MSX-DOS incorrectly assumes that this is the end of string mark and the string is truncated.

This bug is corrected in MSX-DOS 2.50, so the ESC-Y escape sequence can be safely used.


    2. Fast STROUT mode

The STROUT function is actually translated into a series of calls to the CONOUT function. This is done this way because the string to be printed can have any arbitrary length, so it can't be copied to any internal buffer before setting up paging for the MSX-DOS environment. This makes the STROUT function to work very slowly.

In MSX-DOS 2.50, the "Fast STROUT mode" is introduced. When this mode is activated, the string is copied to a 512 byte buffer in page 3 (the sector buffer pointed by SECBUF) and then the string is printed out from code in the MSX-DOS code segment, thus needing one single paging operation and speeding up the printing process. The drwawback of this mode is that the maximum string length is 511 characters; if the string is longer, only the first 511 characters will be printed.

The fast STROUT mode affects also the behavior of the new function ZSTROUT.

The fast STROUT mode can be activated or deactivated by using the new FOUT function.


    3. Block memory allocation routines

The mapper support routines have been extended with two new functions that allow the allocation of small blocks of memory (from 1 to 16378 bytes) within an allocated or TPA segment. Entries for these functions are available as an extension of the mapper support routines jump table whose address can be obtained by using extended BIOS. The names and locations in the jump table of these new routines are:

    +30h: BLK_ALLOC
    +33h: BLK_FREE

Both routines work on the memory that is switched on page 2 at the moment of calling them. It may be an explicitly allocated segment, a TPA segment, or even non-mapped RAM: they will work on any writable memory that is visible on page 2. However a segment will be assumed to be switched on page 2 for documentation purposes.

Following is the description of these routines.


    BLK_ALLOC: Allocate a memory block
    Entry:   HL = Required size (1 to 16378 bytes)
    Returns: On success:
                HL = Address of the allocated block (always a page 2 address)
                A  = 0 and Z set
             On error (not enough free space on segment):
                HL = 0
                A  = .NORAM and Z reset

This routine tries to allocate a memory block of the specified size on the segment currently switched on page 2, and returns the address of the allocated block if it succeeds, or a "Not enough memory" error if not. The segment must have been previously initialized by calling the BLK_FREE routine with HL=0, otherwise the result is unpredictable.


    BLK_FREE: Free a memory block
    Entry:  HL = Address of the allocated block as returned by BLK_ALLOC, or 0 to initialize the segment

This routine frees a memory block on the segment currently switched on page 2. The specified address must be a block address previously returned by the BLK_ALLOC routine on the same segment, otherwise the result is unpredictable. The freed space will become available for new allocations.

All the state information about allocated and free blocks is stored on the segment itself, MSX-DOS does not store any internal information about block memory allocation. This means that when all the allocated blocks on a given segment are no longer needed, it is not needed to explicitly free all blocks one by one; instead, the segment may be overwritten with any other data, the segment itself may be freed, or (in case of TPA segments) application may terminate directly.

When called with HL=0, this routine initializes the segment currently switched on page 2 for block memory allocation. It is necessary to do this routine once before performing any block allocation on the segment. Also, this is useful on segments that already have allocated blocks, as a fast way to free all blocks at once.


    4. Support for the FAT16 filesystem

MSX-DOS 2.31 could access devices formatted with the FAT12 filesystem only, and worked internally with 16 bit sector numbers. MSX-DOS 2.50 has native support for the FAT16 filesystem, and works internally with 23 bit sector numbers. Some functions have been modified, and some other new functions have been added, in order to account for this new capability. It is possible to boot from a FAT16 drive as well.

Two new functions are added, RDDRV and WRDRV, that allow absolute sector reading and writing by specifying 32 bit sector numbers.


    5. Support for disks with standard boot sector

MSX-DOS 2.31 recognized two types of disks based on the boot sector. Those having the "VOL_ID" string at position +20h of the boot sector were recognized as MSX-DOS 2 disks, and special features such as a four byte volume ID (used for testing for disk change) and a dirty disk flag (used to inform that the disk has deleted files that can be undeleted) were available for these disks; those not having the "VOL_ID" string were considered disks formatted with MSX-DOS 1 and the mentioned special features were not available.

MSX-DOS 2.50 still supports DOS 2.31 disks but includes also support for disks with standard boot sectors, that is, disks formatted or partitioned with other systems. Specifically, now four different types of boot sectors are supported:


    * MSX-DOS 2.31 disks

These are the disks that have the "VOL_ID" string at position +20h of the boot sector. Volume ID and dirty disk flag are used on theses disks as usual.


    * Standard disks formatted by MSX-DOS

These are the disks that have on the boot sector an extended block (byte 28h or 29h at position 26h, and string "FAT12" or "FAT16" at position 36h) and whose manufacturar name (at position 3) is "MSXDOS25". These disks have a four byte volume ID at the same position as MSX-DOS 2.31 disks, which will be used as on these disks. Also, the "reserved" field (at position 25h) will be used as the dirty disk flag.


    * Standard disks NOT formatted by MSX-DOS

These are the same as the standard disks formatted by MSX-DOS, except that the manufacturer name is not "MSXDOS25". On these disks, the volume ID will be used, but there will be no dirty disk flag available.


    * Other disks

Disks not in the previous three categories will be considered to be MSX-DOS 1 disks. Neither volume ID nor dirty disk flag will be available for these disks.


    6. The reduced allocation information mode

The ALLOC function returns information about the total and free space in a disk as a cluster count. Multiplying this number by the amount of sectors per cluster used by the disk, the total or free space in sectors is obtained.

Until now, since MSX-DOS supported only the FAT12 filesystem and 16 bit sector numbers, the sector count obtained in this way was always a number that fitted in 16 bits. However this is not true anymore: MSX-DOS 2.50 supports the FAT16 filesystem and 23 bit sector numbers, so the ALLOC function may return a cluster count and a sectors/cluster amount that, when multiplied together, results in a number that needs more than 16 bit to be stored.

This may pose problems on old applications that assume that the sector count will fit in 16 bits, since these applications will obtain a wrong value. For example, assume an application that calculates the free space on disk before allowing the user to save data. If the disk is FAT16 and has 10002h free sectors, the application will calculate it as 2 free sectors only (the highest bit overflows and it will be almost for sure ignored), thus not allowing the user to save data.

To solve this, the reduced allocation information mode is introduced. When this mode is active for a given drive, ALLOC will return a false total or free cluster count if necessary, so when multiplying this number by the amount of sectors/cluster the resulting quantity alwys fits in 16 bits. In other words, on drives with the reduced allocation information mode active, when the total or free space is greater than 32MB, ALLOC will return 32MB.

Example: on a drive with a total size of 100MB and 20MB of free space, when the reduced allocation information mode is active ALLOC will inform 32MB total space and 20MB free space.

The reduced allocation information mode is initially disabled. It can be enabled on a per drive basis by using the new function RALLOC. There is also a new function, DSPACE, that returns the disk total or free space information as a 32 bit amount of KBytes.


    7. Mounting drives

In MSX-DOS 2.50, drives can now be mounted, in a somewhat similar way as in the Unix/Linux operating system. When a drive is mounted, MSX-DOS will assume that the disk in the drive will never be changed, and therefore will never ask the disk driver for disk change status; this results in an overall increase on disk access speed. This is especially useful when using a removable device, such as a multimedia memory card, as the main storage device for the MSX.

No disks are mounted by default. Disks can be mounted and unmounted by using the new function MOUNT. Also, a mounted disk will be automatically unmounted when a disk error on that disk is aborted.


    8. New, fully documented, disk driver system

In the past, MSX developers willing to build their own massive storage device controllers (such as hard disk controllers) with the MSX-DOS kernel embedded, had to reverse engineer the kernel code and guess 1) where to put their own hardware access code mixed with the kernel code itself, 2) the routines, and their input and output parameters, that the kernel code expected to be available for performing disk access, and 3) which parts of the kernel code had to be patched in order to make the whole thing to work.

This changes in MSX-DOS 2.50. Now there is explicit, documented support for building a DOS kernel ROM with an embedded disk driver. Massive storage controller developers willing to deliver their hardware with the MSX-DOS 2.50 kernel embedded just need to develop the code for low-level access to the massive storage harwdare, and combine it with the MSX-DOS 2.50 kernel, as explained with detail in the Driver Development Guide (file DRIVERS.TXT).


    8.1. Device-based drivers

When developing a device driver for MSX-DOS 2.50 the developer has the option to make it a device-based driver. These drivers do not provide routines to directly access the disk drives associated to the driver, as it was the case in older versions of MSX-DOS. Instead, device-based drivers provide routines to directly access the storage devices controlled by the driver. For example, in a multimedia card controller with two slots, the driver will need to serve requests like "check if there is a card in slot 1" or "read sector X from the card in slot 2".

Choosing to develop a device-based driver for a massive storage controller has one big advantage: MSX-DOS will handle the drive letter to device mapping, as well as the drive letter to disk partition mapoing (there are new function calls and related utility applications that allow the user to control this mapping). Other features available for device-based drivers, to be implemented in future versions, are: built-in disk paritionning tool, and support for direct filesystem access (so devices sucha as CD-ROMs or disks with non-FAT filesystems can be accessed).

There are more details about device-based driver development in the Driver Development Guide (file DRIVERS.TXT).


    8.2. Drive and partition auto-assign procedure for device-based drivers

In older versions of MSX-DOS (and in MSX-DOS 2.50, when not using device-based drivers), it is the disk driver itself who decides how many drive letters wants to handle, as well as how to map drive letters to devices/disk partitions. In MSX-DOS 2.50, this is no longer the case when using device-based drivers: the user can freely map any drive letter to any device/partition controlled by the driver.

There is a question that arises with this new system: when using device-based drivers, ¿how many drive letters does MSX-DOS assign for the driver, and how are devices and partitions mapped to drive letters, at boot time? The answer is:

- Two drive letters are assigned to each device-based driver at boot time. Note however that once the system has booted, the user can map any drive letter to a device on a device-based driver, not only to the two initially assigned drives (see the new function calls GDRVR, GDLI, GPART and MAPDRV; as well as the new utility routines DRIVERS.COM, DRVINFO.COM and MAPDRV.COM).

- An auto-assign procedure is performed at boot time for the initial assignment of devices to the two assigned drives.

The auto-assign procedure scans all the available devices on the driver, and assigns the first suitable device found. The following rules are followed when serching for a suitable device:

* A device is searched having the smallest device and logical unit number, which is online (if it is removable), has at least one properly formatted FAT12 or FAT16 primary partition, and contains a file named MSXDOS2.DAT in the root directory of the first of these partitions (the contents of the file is irrelevant, it may be even an empty file). Extended partitions are ignored. If the device does not hold a valid partition table, then the whole device space is treated as one single primary partition.

* If no device is found in the previous step, the first available device is selected (the device having the smallest device and logical unit number), even if it is a removable device with no media inserted.

* If no device is found in the previous step, the drive will remain unmapped.

* For the second drive, the same rules are used, except that the device/logical unit already mapped to the first drive is skipped.


    9. MSX-DOS 1

The MSX-DOS 2.50 kernel includes the MSX-DOS 1 kernel, which is activated when a DOS 1 boot sector is found in the disk assigned to drive A: at boot time, or when the user presses the "1" key at boot time.

The DOS 1 kernel embedded with MSX-DOS 2.50 is the same one that is embedded with the MSX-DOS 2.3x kernel, except that is has been modified to support the new driver system. When booting in DOS 1 mode, the same drive/partition auto-assign procedure is used for device-based drivers as when booting in DOS 2 mode, except that FAT16 partitions and FAT12 partitions having more than tree sectors per cluster are ignored when searching for a MSXDOS2.DAT file.

When booting in DOS 1 mode, and if there is at least one device-based driver in the system, then a table is created that contains information about the drive to device/partition mapping. A pointer to this table is stored at address 0F314h (when this pointer is zero, the table does not exist); the table is vreated in a reserved space in page 3. The contents of this table is as follows:

+0: Number of entries in the table
+1..+8: First table entry
+9..+16: Second table entry
etc...

Each entry consists of the following:

+0: Driver slot number
+1: Relative unit number for the driver
+2: Device index
+3: LUN index
+4..+7: First device absolute sector for the drive (that is, first sector number of the assigned partition)

At this moment there is no way to change the drive to device/partition mapping when booting in DOS 1 mode; the mappings automatically performed at boot time are permanent. This will change in future versions.


    10. More meaningful boot error messages

In previous versions of MSX-DOS 2, when an error that prevented the system from booting occured, a generic "Not enough memory" message appeared. Now a more meaningful error message appears, telling the real cause of the error.


    11. Disablable Z80 access mode for legacy drivers

In previous versions of MSX-DOS 2, and when running in MSX Turbo-R, the Z80 CPU was always switched prior to performing any disk access. This was done because some old floppy disk drives do not work when acessed in R800 mode.

In MSX-DOS 2.50, the concept of "Z80 access mode" is introduced. Z80 access mode is enabled by default for all legacy drivers (drivers embedded in a MSX-DOS 1/2.20/2.3x kernel ROM), meaning that the Z80 CPU was switched when accessing any drive associated to these drivers. However, this mode can be disabled for any driver, so that drives in these drivers can be accessed in R800 mode. There is a new funcion call, Z80MODE, and a new utility program, Z80MODE.COM, which allow to enable and disable the Z80 access mode for any legacy driver.

Note that this applies to legacy drivers only. MSX-DOS will never switch the Z80 CPU when accessing device-based or drive-based drivers.
